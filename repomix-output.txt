This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-10T04:14:51.348Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  AI/
    adding_new_game_levels.md
public/
  fonts/
    Orbitron/
      OFL.txt
      README.txt
  vite.svg
src/
  assets/
    react.svg
  components/
    Game/
      BackgroundEffects.ts
      CaveEffects.ts
      Flora.ts
      GameHelpers.ts
      GameLoop.ts
      ParticleEffects.ts
      Player.ts
    GameUI/
      AboutModal.tsx
      GameControls.tsx
      HealthBar.tsx
      LevelCompleteScreen.tsx
      LevelSelector.tsx
      PauseScreen.tsx
      PortraitScreen.tsx
      ProgressBar.tsx
      StreakDisplay.tsx
      WelcomeScreen.tsx
    MusicReactiveOceanGame.tsx
  hooks/
    useAudio.ts
    useGameState.ts
    useInputHandler.ts
  utils/
    assetLoader.ts
    colorUtils.ts
    eventData.ts
  App.css
  App.tsx
  index.css
  index.ts
  main.tsx
  types.ts
  vite-env.d.ts
.gitignore
eslint.config.js
index.html
netlify.toml
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: docs/AI/adding_new_game_levels.md
================
# Adding New Game Levels to CVCHE

This document outlines the step-by-step process for adding a new level to the CVCHE game. This guide was created after successfully implementing Level 3.

## Overview

Adding a new level requires modifications to several key files:

1. **Types** - Define new level-specific event types
2. **Asset Loader** - Add code to load level-specific assets
3. **Game State Hook** - Update the game state to handle the new level
4. **Game Helpers** - Implement level-specific gameplay mechanics
5. **Game Loop** - Integrate the new level into the main game loop

## 1. Update Asset Loader

First, modify the `AssetLoader` class in `src/utils/assetLoader.ts` to handle new level assets:

```typescript
// Add level-specific asset properties
// Level 3 specific assets
cloudImage: HTMLImageElement | null = null;
eagleImage: HTMLImageElement | null = null;

// Add collections for the level assets
level3ObstacleImages: HTMLImageElement[] = [];
level3MushroomImages: HTMLImageElement[] = [];
level3TrippyImages: HTMLImageElement[] = [];

// Add a status flag for the level
level3AssetsLoaded = false;

// Implement load function for the new level assets
async loadLevel3Assets(): Promise<void> {
  // Load obstacle images
  const obstaclePromises = [
    this.loadImage('/sprites/level3/obstacles/clouds.png').then(img => {
      this.cloudImage = img;
      this.level3ObstacleImages.push(img);
    }),
    this.loadImage('/sprites/level3/obstacles/eagle.png').then(img => {
      this.eagleImage = img;
      this.level3ObstacleImages.push(img);
    })
  ];
  
  // Load pickup images
  const mushroomPromises = [];
  for (let i = 1; i <= 9; i++) {
    mushroomPromises.push(
      this.loadImage(`/sprites/level3/mushrooms/mushroom (${i}).png`).then(img => {
        this.level3MushroomImages.push(img);
      })
    );
  }
  
  // Load other assets
  const trippyTypes = [
    'baby', 'baby2', 'blueMan', 'gummyWorm', 'kitten', 
    'magicRabbit', 'pomeranian', 'squirtToy', 'woman'
  ];
  
  const trippyPromises = trippyTypes.map(type => {
    const ext = type === 'blueMan' ? 'jpg' : 'png';
    return this.loadImage(`/sprites/level3/trippyPickups/${type}.${ext}`).then(img => {
      this.level3TrippyImages.push(img);
    });
  });
  
  await Promise.all([...obstaclePromises, ...mushroomPromises, ...trippyPromises]);
  this.level3AssetsLoaded = true;
}
```

## 2. Update Game State Hook

Extend the `useGameState` hook in `src/hooks/useGameState.ts`:

```typescript
// Import the new level type
import { GameState, Level, LevelToggles, ActiveTimedText, ActiveColor, CaveState, Bubble, Flora, StreakDisplay, TimedTextEvent, TimedColorEvent, Level2TimedEvents, Level3TimedEvents, Particle } from '../types';
import { getDefaultLevels, createDefaultTimedTextEvents, createLevel2TimedTextEvents, createLevel3TimedTextEvents, createColorEventsByLevel, createLevel2TimedEvents, createLevel3TimedEvents, getInitialLevelToggles } from '../utils/eventData';

// Add reference for level-specific events
const level3TimedEventsRef = useRef<Level3TimedEvents>(createLevel3TimedEvents());

// Add references for level assets
const level3ObstacleImagesRef = useRef<HTMLImageElement[]>([]);
const level3MushroomImagesRef = useRef<HTMLImageElement[]>([]);
const level3TrippyImagesRef = useRef<HTMLImageElement[]>([]);

// Update selectLevel callback to handle the new level
const selectLevel = useCallback(async (level: Level) => {
  // ...existing code...
  
  if (level.id === 3) {
    if (containerRef.current) {
      containerRef.current.style.background = "transparent";
    }
    timedTextEventsRef.current = createLevel3TimedTextEvents();
    const loadLevel3Assets = async () => {
      if (gameStateRef.current.gameStarted) {
        setIsPaused(true);
      }
      const assetLoader = new AssetLoader();
      await assetLoader.loadLevel3Assets();
      level3ObstacleImagesRef.current = assetLoader.level3ObstacleImages;
      level3MushroomImagesRef.current = assetLoader.level3MushroomImages;
      level3TrippyImagesRef.current = assetLoader.level3TrippyImages;
      setLevelEnded(false);
      setHealth(100);
      if (gameStateRef.current.gameStarted) {
        setIsPaused(false);
      }
    };
    // Load level assets
    await loadLevel3Assets();
  }
  
  // ...rest of the function
}, [levels, setIsPaused, setLevelEnded, setHealth]);

// Update return object to include new refs
return {
  // ...existing properties
  level3ObstacleImagesRef,
  level3MushroomImagesRef,
  level3TrippyImagesRef,
  level3TimedEventsRef,
  // ...rest of properties
};
```

## 3. Update Game Helpers

Extend the `GameHelpers.ts` file to handle level-specific gameplay mechanics:

```typescript
// Update the import
import { LevelToggles, GameState, Level3TimedEvents } from '../../types';

// Add level-specific toggles in updateLevelToggles function
else if (currentLevelId === 3) {
  if (audioTime < 3) {
    levelTogglesRef.current = {
      showFlora: false,
      showBags: false,
      showBottles: false,
      showOilSplats: false,
      showHooks: false,
      showVisualizer: true,
      showBubbles: false,
      showBackgroundPattern: false,
      showFlipFlops: false,
      showToothbrushes: false,
      showHotdogs: false,
      showRubberDuckies: false,
      // Level 3 specific toggles
      showClouds: false,
      showMushrooms: false,
      showEagles: false,
      showTrippyObjects: false,
      showStormEffects: false
    };
  }
  // Add more timing-based toggles...
}

// Add a function to process level-specific events
export const processLevel3Events = (
  audioTime: number,
  canvas: HTMLCanvasElement,
  level3TimedEvents: Level3TimedEvents,
  level3ObstacleImages: HTMLImageElement[],
  level3MushroomImages: HTMLImageElement[],
  level3TrippyImages: HTMLImageElement[],
  gameState: GameState
) => {
  // Process obstacles
  level3TimedEvents.obstacles.forEach((event) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;
      // Spawn an obstacle
      // ...
    }
  });

  // Process pickups
  level3TimedEvents.pickups.forEach((event) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;
      // Spawn a pickup
      // ...
    }
  });

  // Process visual effects
  level3TimedEvents.visuals.forEach((event) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;
      // Create a visual effect
      // ...
    }
  });
};
```

## 4. Update Game Loop

Extend the `GameLoop.ts` file to integrate the new level:

```typescript
// Update import to include new level type
import { GameState, LevelToggles, ActiveTimedText, TimedTextEvent, TimedColorEvent, Level2TimedEvents, Level3TimedEvents, ActiveColor, Bubble, StreakDisplay, Level, CaveState } from '../../types';
import { processColorEvents, processLevel2Events, processLevel3Events, spawnItemsOnBeat, updateAndCheckObstacleCollisions, updateAndCheckTrashCollisions, updateLevelToggles } from './GameHelpers';

// Add the new level assets to the function parameters
level3ObstacleImagesRef: React.MutableRefObject<HTMLImageElement[]>,
level3MushroomImagesRef: React.MutableRefObject<HTMLImageElement[]>,
level3TrippyImagesRef: React.MutableRefObject<HTMLImageElement[]>,

// Add the level events ref to the function parameters
level3TimedEventsRef: React.MutableRefObject<Level3TimedEvents>,

// Add conditional processing based on level ID
if (currentLevelRef.current.id === 2) {
  processLevel2Events(
    audioTime, 
    canvasRef.current, 
    level2TimedEventsRef.current, 
    level2ObstacleImagesRef.current,
    level2PickupImagesRef.current,
    gameStateRef.current
  );
} else if (currentLevelRef.current.id === 3) {
  processLevel3Events(
    audioTime,
    canvasRef.current,
    level3TimedEventsRef.current,
    level3ObstacleImagesRef.current,
    level3MushroomImagesRef.current,
    level3TrippyImagesRef.current,
    gameStateRef.current
  );
}

// Update the gameLoop requestAnimationFrame call to include the new parameters
animationFrameIdRef.current = requestAnimationFrame(() => gameLoop(
  // ...existing parameters
  level3ObstacleImagesRef,
  level3MushroomImagesRef,
  level3TrippyImagesRef,
  // ...existing parameters
  level3TimedEventsRef,
  // ...remaining parameters
));
```

## 5. Update Event Data (if needed)

If your level needs custom event handling, update `src/utils/eventData.ts` to include functions to create level-specific timed events:

```typescript
export const createLevel3TimedTextEvents = (): TimedTextEvent[] => {
  return [
    { text: "HAVE YOU EVER HAD A FEELING YOU COULD FLY", timestamp: 6, triggered: false, lifetime: 250 },
    { text: "GET FLUFFY WITH FLUFFY", timestamp: 30, triggered: false, lifetime: 250 },
    // Other text events for the level
  ];
};

export const createLevel3TimedEvents = (): Level3TimedEvents => {
  return {
    obstacles: [
      // Eagles, clouds, etc.
      { type: 'eagle', timestamp: 210, triggered: false },
            // Cloud and trippy effects
      { type: 'cloud', timestamp: 3, triggered: false },
    ],
    pickups: [
      // Mushrooms
      { type: 'mushroom', timestamp: 71, triggered: false },
      //trippy
          { type: 'trippy', timestamp: 71, triggered: false },
    ],

  };
};
```

## 6. Testing Your Level

To test the new level:

1. Ensure all asset files are in the correct directories
2. Verify that the level-specific event processing is working
3. Check that transitions between levels work correctly
4. Test gameplay mechanics specific to your level

## Common Issues and Solutions

- **Missing assets**: Double-check that all asset paths are correct and files exist
- **Timing issues**: Verify that timestamps align with the music
- **Type errors**: Ensure all new types are properly defined and imported
- **Asset loading failures**: Log loading progress and check browser console for errors

## Final Tips

- Keep level-specific code encapsulated to make maintenance easier
- Follow the existing patterns when adding new features
- Test thoroughly after each significant change

================
File: public/fonts/Orbitron/OFL.txt
================
Copyright 2018 The Orbitron Project Authors (https://github.com/theleagueof/orbitron), with Reserved Font Name: "Orbitron"

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
https://openfontlicense.org


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

================
File: public/fonts/Orbitron/README.txt
================
Orbitron Variable Font
======================

This download contains Orbitron as both a variable font and static fonts.

Orbitron is a variable font with this axis:
  wght

This means all the styles are contained in a single file:
  Orbitron-VariableFont_wght.ttf

If your app fully supports variable fonts, you can now pick intermediate styles
that aren’t available as static fonts. Not all apps support variable fonts, and
in those cases you can use the static font files for Orbitron:
  static/Orbitron-Regular.ttf
  static/Orbitron-Medium.ttf
  static/Orbitron-SemiBold.ttf
  static/Orbitron-Bold.ttf
  static/Orbitron-ExtraBold.ttf
  static/Orbitron-Black.ttf

Get started
-----------

1. Install the font files you want to use

2. Use your app's font picker to view the font family and all the
available styles

Learn more about variable fonts
-------------------------------

  https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts
  https://variablefonts.typenetwork.com
  https://medium.com/variable-fonts

In desktop apps

  https://theblog.adobe.com/can-variable-fonts-illustrator-cc
  https://helpx.adobe.com/nz/photoshop/using/fonts.html#variable_fonts

Online

  https://developers.google.com/fonts/docs/getting_started
  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide
  https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/variable-fonts

Installing fonts

  MacOS: https://support.apple.com/en-us/HT201749
  Linux: https://www.google.com/search?q=how+to+install+a+font+on+gnu%2Blinux
  Windows: https://support.microsoft.com/en-us/help/314960/how-to-install-or-remove-a-font-in-windows

Android Apps

  https://developers.google.com/fonts/docs/android
  https://developer.android.com/guide/topics/ui/look-and-feel/downloadable-fonts

License
-------
Please read the full license text (OFL.txt) to understand the permissions,
restrictions and requirements for usage, redistribution, and modification.

You can use them in your products & projects – print or digital,
commercial or otherwise.

This isn't legal advice, please consider consulting a lawyer and see the full
license for all details.

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/Game/BackgroundEffects.ts
================
import { Bubble } from '../../types';

/**
 * Draw the background of the game
 */
export const drawBackground = (
  ctx: CanvasRenderingContext2D, 
  amplitudeFactor: number, 
  backgroundColorRef: React.MutableRefObject<string>,
  currentLevelId: number,
  showBackgroundPattern: boolean,
  bgPatternBubblesRef: React.MutableRefObject<Bubble[]>
) => {
  if (!ctx.canvas) return;
  
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  
  // Skip drawing background for level 2 (video background)
  if (currentLevelId === 2) {
    ctx.clearRect(0, 0, width, height);
    return;
  }
  
  // Fill with base color
  ctx.fillStyle = backgroundColorRef.current;
  ctx.fillRect(0, 0, width, height);
  
  // Create radial gradient for glow effect
  const gradientSize = Math.max(width, height) * (0.8 + amplitudeFactor * 0.4);
  const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, gradientSize);
  const alpha = 0.15 + amplitudeFactor * 0.2;
  gradient.addColorStop(0, `rgba(255,255,255,${alpha})`);
  gradient.addColorStop(0.5, `rgba(255,255,255,${alpha * 0.5})`);
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  
  // Create vignette effect
  const vignetteGradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.7);
  vignetteGradient.addColorStop(0, 'rgba(0,0,0,0)');
  vignetteGradient.addColorStop(0.7, `rgba(0,0,0,${0.2 + amplitudeFactor * 0.1})`);
  vignetteGradient.addColorStop(1, `rgba(0,0,0,${0.3 + amplitudeFactor * 0.15})`);
  ctx.fillStyle = vignetteGradient;
  ctx.fillRect(0, 0, width, height);
  
  // Draw background pattern if enabled
  if (showBackgroundPattern) {
    drawBackgroundPattern(ctx, amplitudeFactor, bgPatternBubblesRef);
  }
};

/**
 * Draw the background pattern
 */
export const drawBackgroundPattern = (
  ctx: CanvasRenderingContext2D, 
  amplitudeFactor: number, 
  bgPatternBubblesRef: React.MutableRefObject<Bubble[]>
) => {
  if (!ctx.canvas) return;
  
  ctx.save();
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  const currentTime = Date.now();
  
  // Create wave pattern at bottom
  for (let x = 0; x <= width; x += 5) {
    const timeOffset = currentTime / 1000;
    const frequency = 4 + Math.sin(timeOffset) * 2 * (1 + amplitudeFactor * 0.5);
    const y = height + Math.sin((x / width * frequency * Math.PI) + timeOffset) * (50 + amplitudeFactor * 70);
    
    // Randomly add bubbles
    if (Math.random() < 0.1) {
      bgPatternBubblesRef.current.push({
        x,
        y,
        radius: 2 + Math.random() * 2,
        speed: 0.3 + Math.random() * 0.2,
        opacity: 1,
      });
    }
  }
  
  // Update and draw bubbles
  for (let i = bgPatternBubblesRef.current.length - 1; i >= 0; i--) {
    const bubble = bgPatternBubblesRef.current[i];
    bubble.y -= bubble.speed;
    bubble.opacity -= 0.005;
    
    if (bubble.opacity <= 0 || bubble.y + bubble.radius < 0) {
      bgPatternBubblesRef.current.splice(i, 1);
      continue;
    }
    
    ctx.beginPath();
    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(173,216,230,${bubble.opacity})`;
    ctx.fill();
  }
  
  ctx.restore();
};

/**
 * Draw the audio spectrum visualizer
 */
export const drawSpectrum = (
  ctx: CanvasRenderingContext2D, 
  analyserRef: React.MutableRefObject<AnalyserNode | null>,
  dataArrayRef: React.MutableRefObject<Uint8Array | null>,
  waveColorRef: React.MutableRefObject<string>
) => {
  const analyser = analyserRef.current;
  const dataArray = dataArrayRef.current;
  
  if (!analyser || !dataArray || !ctx.canvas) return;
  
  const barWidth = (ctx.canvas.width / dataArray.length) * 2.5;
  let posX = 0;
  
  analyser.getByteFrequencyData(dataArray);
  
  for (let i = 0; i < dataArray.length; i++) {
    const barHeight = dataArray[i] / 2;
    const gradient = ctx.createLinearGradient(0, ctx.canvas.height, 0, ctx.canvas.height - barHeight);
    
    let startColor = waveColorRef.current, endColor = waveColorRef.current;
    
    // Handle rgba color format
    if (waveColorRef.current.startsWith('rgba')) {
      const components = waveColorRef.current.match(/[\d.]+/g);
      if (components && components.length >= 4) {
        const [r, g, b] = components;
        startColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
        endColor = `rgba(${r}, ${g}, ${b}, 0)`;
      }
    } 
    // Handle hex color format
    else if (waveColorRef.current.startsWith('#')) {
      const hex = waveColorRef.current.slice(1);
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      startColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
      endColor = `rgba(${r}, ${g}, ${b}, 0)`;
    }
    
    gradient.addColorStop(0, startColor);
    gradient.addColorStop(1, endColor);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(posX, ctx.canvas.height - barHeight, barWidth, barHeight);
    
    posX += barWidth + 1;
  }
};

/**
 * Update and draw bubble effects
 */
export const updateAndDrawBubbles = (ctx: CanvasRenderingContext2D, bubbles: Bubble[], amplitude: number, factor: number) => {
  const canvas = ctx.canvas;
  if (!canvas) return;
  
  // Add new bubbles based on audio amplitude
  if (Math.random() < (amplitude / 255) * 0.5) {
    bubbles.push({
      x: Math.random() * canvas.width,
      y: canvas.height,
      radius: 2 + Math.random() * 3,
      speed: 1 + Math.random() * 2,
      opacity: 1,
    });
  }
  
  // Update and draw existing bubbles
  for (let i = bubbles.length - 1; i >= 0; i--) {
    const bubble = bubbles[i];
    bubble.y -= bubble.speed * factor;
    bubble.opacity -= 0.005 * factor;
    
    if (bubble.opacity <= 0 || bubble.y + bubble.radius < 0) {
      bubbles.splice(i, 1);
      continue;
    }
    
    ctx.beginPath();
    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(173,216,230,${bubble.opacity})`;
    ctx.fill();
  }
};

/**
 * Update and draw score popups
 */
export const updateAndDrawScorePopups = (ctx: CanvasRenderingContext2D, popups: any[], factor: number) => {
  for (let i = popups.length - 1; i >= 0; i--) {
    const popup = popups[i];
    
    ctx.save();
    ctx.font = "20px Orbitron";
    ctx.fillStyle = "black";
    ctx.globalAlpha = popup.opacity;
    ctx.fillText(popup.text, popup.x, popup.y);
    ctx.restore();
    
    popup.y -= 0.5 * factor;
    popup.lifetime -= factor;
    popup.opacity = popup.lifetime / 100;
    
    if (popup.lifetime <= 0) popups.splice(i, 1);
  }
};

/**
 * Update and draw timed text events
 */

export const updateAndDrawTimedTexts = (ctx: CanvasRenderingContext2D, activeTimedTexts: any[], factor: number) => {
  if (!ctx.canvas) return;
  
  // Remove expired text events before processing
  for (let i = activeTimedTexts.length - 1; i >= 0; i--) {
    activeTimedTexts[i].lifetime -= factor;
    if (activeTimedTexts[i].lifetime <= 0) {
      activeTimedTexts.splice(i, 1);
    }
  }
  
  // Only display one text at a time (the most recent one)
  if (activeTimedTexts.length > 0) {
    const item = activeTimedTexts[activeTimedTexts.length - 1];
    let fontSize = 80;
    const margin = 40;
    
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Adjust font size to fit within canvas width
    let textWidth;
    do {
      ctx.font = `${fontSize}px Orbitron`;
      textWidth = ctx.measureText(item.text).width;
      if (textWidth > (ctx.canvas?.width ?? 400) - margin) {
        fontSize -= 2;
      } else {
        break;
      }
    } while (fontSize > 10);
    
    const opacity = item.lifetime / 200;
    ctx.fillStyle = item.color ?? `rgba(0, 0, 0, ${opacity})`;
    ctx.fillText(item.text, (ctx.canvas?.width ?? 400) / 2, (ctx.canvas?.height ?? 200) / 2);
    ctx.restore();
  }
};

================
File: src/components/Game/CaveEffects.ts
================
import { CaveState, Player, Particle } from '../../types';
import { createParticles } from './ParticleEffects';

/**
 * Update cave boundaries based on audio amplitude
 */
export const updateCaveBoundaries = (
  canvas: HTMLCanvasElement | null,
  cave: CaveState,
  amplitude: number,
  isDesktop: boolean
) => {
  if (!canvas) return;
  
  const time = Date.now() / 1000;
  cave.upper.points = [];
  cave.lower.points = [];
  
  const playerMinWidth = 50; // Default player width
  const minCaveHeight = playerMinWidth * 3;
  const maxAmplitude = (canvas.height - minCaveHeight) / 2;
  const computedBeatAmplitude = amplitude * 4;
  
  // Limit amplitude more for desktop to avoid difficult gameplay
  const effectiveBeatAmplitude = isDesktop
    ? Math.min(computedBeatAmplitude, 50)
    : Math.min(computedBeatAmplitude, maxAmplitude);
  
  const centerY = canvas.height / 2;
  
  // Create cave boundary points
  for (let x = 0; x <= canvas.width; x += 10) {
    const waveOffset = Math.sin(x / 150 + time * 3) * effectiveBeatAmplitude +
      Math.sin(x / 75 + time * 2) * (effectiveBeatAmplitude * 0.5) +
      Math.sin(x / 37.5 + time * 4) * (effectiveBeatAmplitude * 0.25);
    
    const curveY = centerY + waveOffset;
    
    cave.upper.points.push({
      x,
      y: curveY - minCaveHeight - (effectiveBeatAmplitude * 0.5)
    });
    
    cave.lower.points.push({
      x,
      y: curveY + minCaveHeight + (effectiveBeatAmplitude * 0.5)
    });
  }
};

/**
 * Draw cave effect
 */
export const drawCaveEffect = (
  ctx: CanvasRenderingContext2D,
  cave: CaveState,
  amplitude: number,
  isWarningPeriod: boolean
) => {
  const canvas = ctx.canvas;
  if (!canvas) return;
  
  ctx.save();
  
  // Set opacity based on warning period
  const caveFillOpacity = isWarningPeriod
    ? 0.5 + 0.5 * Math.abs(Math.sin(Date.now() / 100))
    : 0.75;
  
  // Draw upper cave wall
  ctx.fillStyle = `rgba(26, 26, 26, ${caveFillOpacity})`;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  cave.upper.points.forEach(point => {
    ctx.lineTo(point.x, point.y);
  });
  ctx.lineTo(canvas.width, 0);
  ctx.fill();
  
  // Draw lower cave wall
  ctx.beginPath();
  ctx.moveTo(0, canvas.height);
  cave.lower.points.forEach(point => {
    ctx.lineTo(point.x, point.y);
  });
  ctx.lineTo(canvas.width, canvas.height);
  ctx.fill();
  
  // Draw center line with glow effect
  ctx.beginPath();
  const caveStrokeOpacity = isWarningPeriod
    ? 0.5 + 0.5 * Math.abs(Math.sin(Date.now() / 100))
    : 0.3 + (amplitude / 255) * 0.7;
  
  // Draw center line connecting upper and lower cave points
  cave.upper.points.forEach((point, i) => {
    const lowerPoint = cave.lower.points[i];
    const centerY = (point.y + lowerPoint.y) / 2;
    if (i === 0) {
      ctx.moveTo(point.x, centerY);
    } else {
      ctx.lineTo(point.x, centerY);
    }
  });
  
  // Give it a nice glow effect
  const hue = 120; // Green hue for center line
  ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${caveStrokeOpacity})`;
  ctx.lineWidth = 4 + (amplitude / 255) * 6;
  ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
  ctx.shadowBlur = amplitude / 10;
  ctx.stroke();
  
  ctx.restore();
};

/**
 * Check if player collides with cave walls and handle collision
 */
export const checkCaveCollision = (
  player: Player,
  cave: CaveState,
  isWarningPeriod: boolean,
  lastCollisionTimeRef: React.MutableRefObject<number>,
  particles: Particle[],
  hitSound: HTMLAudioElement | null,
  setScore: (callback: (prev: number) => number) => void,
  setHealth: (callback: (prev: number) => number) => void,
  scorePopups: any[],
  setStreak: (value: number) => void,
  setMultiplier: (value: number) => void,
  setLevelEnded: (value: boolean) => void,
  gameLoopRef: React.MutableRefObject<boolean>,
  animationFrameIdRef: React.MutableRefObject<number | null>
): boolean => {
  if (isWarningPeriod) return false;
  
  const playerBox = {
    top: player.y,
    bottom: player.y + player.height,
    left: player.x,
    right: player.x + player.width
  };
  
  // Check collision with cave walls
  for (let i = 1; i < cave.upper.points.length; i++) {
    const upperP1 = cave.upper.points[i - 1];
    const upperP2 = cave.upper.points[i];
    const lowerP1 = cave.lower.points[i - 1];
    const lowerP2 = cave.lower.points[i];
    
    if (playerBox.right >= upperP1.x && playerBox.left <= upperP2.x) {
      const t = (playerBox.left - upperP1.x) / (upperP2.x - upperP1.x);
      const upperY = upperP1.y + t * (upperP2.y - upperP1.y);
      const lowerY = lowerP1.y + t * (lowerP2.y - lowerP1.y);
      
      if (playerBox.top <= upperY || playerBox.bottom >= lowerY) {
        const collisionX = playerBox.top <= upperY ? player.x : player.x;
        const collisionY = playerBox.top <= upperY ? upperY : lowerY;
        
        const now = Date.now();
        const PROXIMITY_SCORE_COOLDOWN = 500;
        
        // Don't process collision too frequently
        if (now - lastCollisionTimeRef.current > PROXIMITY_SCORE_COOLDOWN) {
          lastCollisionTimeRef.current = now;
          
          // Create particles at collision point
          createParticles(particles, collisionX, collisionY, '#000000', 30);
          createParticles(particles, collisionX, collisionY, '#FFFFFF', 15);
          
          // Reduce score
          setScore(prev => Math.max(0, prev - 30));
          
          // Reset streak
          setStreak(0);
          setMultiplier(1);
          
          // Show score popup
          scorePopups.push({
            x: collisionX,
            y: collisionY,
            text: "-30",
            opacity: 1,
            lifetime: 100
          });
          
          // Play hit sound
          hitSound?.play().catch(console.error);
          
          // Apply effects to player
          player.spinRotation = Math.PI * 2;
          player.hitTime = now;
          player.hitType = 'obstacle';
          
          // Reduce health
          setHealth(prev => {
            const newHealth = prev - 1;
            if (newHealth <= 0) {
              setLevelEnded(true);
              gameLoopRef.current = false;
              if (animationFrameIdRef.current) {
                cancelAnimationFrame(animationFrameIdRef.current);
                animationFrameIdRef.current = null;
              }
            }
            return newHealth;
          });
          
          return true;
        }
      }
    }
  }
  
  return false;
};

/**
 * Calculate player proximity to center of cave and reward points
 */
export const calculateCaveProximityScore = (
  player: Player,
  cave: CaveState,
  lastProximityScoreTimeRef: React.MutableRefObject<number>,
  setScore: (callback: (prev: number) => number) => void,
  scorePopups: any[]
) => {
  const playerCenterX = player.x + player.width / 2;
  const playerCenterY = player.y + player.height / 2;
  let nearestCenterY = 0;
  let nearestPoint = cave.upper.points[0];
  
  // Find the nearest cave center point to the player
  for (let i = 0; i < cave.upper.points.length; i++) {
    const point = cave.upper.points[i];
    const lowerPoint = cave.lower.points[i];
    const centerY = (point.y + lowerPoint.y) / 2;
    
    if (Math.abs(point.x - playerCenterX) < Math.abs(nearestPoint.x - playerCenterX)) {
      nearestPoint = point;
      nearestCenterY = centerY;
    }
  }
  
  // Calculate proximity to center (1.0 = directly in center, 0.0 = far from center)
  const maxDistance = (cave.upper.points.length > 0 && cave.lower.points.length > 0) ? 
    (cave.lower.points[0].y - cave.upper.points[0].y) / 6 : 100;
  
  const distance = Math.abs(playerCenterY - nearestCenterY);
  const proximity = 1 - Math.min(distance / maxDistance, 1);
  
  // Award points for staying in the center
  const now = Date.now();
  const PROXIMITY_SCORE_COOLDOWN = 500;
  
  if (proximity > 0.5 && now - lastProximityScoreTimeRef.current > PROXIMITY_SCORE_COOLDOWN) {
    lastProximityScoreTimeRef.current = now;
    const proximityBonus = Math.floor(proximity * 50);
    
    if (proximityBonus > 0) {
      setScore(prev => prev + proximityBonus);
      
      scorePopups.push({
        x: player.x,
        y: player.y - 30,
        text: `+${proximityBonus}`,
        opacity: 1,
        lifetime: 60
      });
    }
  }
  
  return proximity;
};

================
File: src/components/Game/Flora.ts
================
import { Flora } from '../../types';

/**
 * Initialize flora elements
 */
export const initializeFlora = (canvas: HTMLCanvasElement, floraImages: HTMLImageElement[]): Flora[] => {
  if (!canvas) return [];
  
  const MAX_FLORA = 50;
  const floraItems: Flora[] = [];
  
  for (let i = 0; i < MAX_FLORA; i++) {
    const randomImage = floraImages[Math.floor(Math.random() * floraImages.length)];
    const height = 30 + Math.random() * 80;
    const width = (height / randomImage.height) * randomImage.width;
    
    floraItems.push({
      x: canvas.width + (Math.random() * canvas.width),
      y: canvas.height,
      width,
      height,
      image: randomImage,
      swayOffset: Math.random() * Math.PI * 2,
      swaySpeed: 0.3 + Math.random() * 0.4,
      scrollSpeed: 1.5 + Math.random(),
      active: true
    });
  }
  
  return floraItems;
};

/**
 * Draw flora items
 */
export const drawFlora = (
  ctx: CanvasRenderingContext2D, 
  floraItems: Flora[], 
  amplitude: number, 
  factor: number, 
  speedMultiplier: number,
  currentLevelId: number
) => {
  if (!ctx.canvas) return;
  
  // Don't draw flora in level 2
  if (currentLevelId === 2) return;
  
  const canvas = ctx.canvas;
  const time = Date.now() / 1000;
  
  floraItems.forEach((flora) => {
    // Update position
    flora.x -= flora.scrollSpeed * speedMultiplier * factor;
    
    // Reset position if off-screen
    if (flora.x + flora.width < 0) {
      flora.x = canvas.width + (Math.random() * canvas.width);
    }
    
    // Set y position at bottom of canvas
    flora.y = canvas.height;
    
    // Draw with swaying effect
    ctx.save();
    const sway = Math.sin(time * flora.swaySpeed + flora.swayOffset) * (5 + amplitude / 10);
    const pivotX = flora.x + flora.width / 2;
    const pivotY = flora.y;
    
    ctx.translate(pivotX, pivotY);
    ctx.rotate(sway * 0.05);
    ctx.globalAlpha = 0.50;
    ctx.drawImage(flora.image, -flora.width / 2, -flora.height, flora.width, flora.height);
    ctx.restore();
  });
};

================
File: src/components/Game/GameHelpers.ts
================
import { LevelToggles, GameState, Level3TimedEvents } from '../../types';
import { drawItem, getSpawnY } from './GameLoop';
import { createParticles } from './ParticleEffects';
import { getParticleColorFromStreak } from '../../utils/colorUtils';

// Declare global window properties
declare global {
  interface Window {
    waterBottleRef?: React.MutableRefObject<HTMLImageElement | null>;
    plasticBagRef?: React.MutableRefObject<HTMLImageElement | null>;
  }
}

/**
 * Update level toggles based on audio time position
 */
export const updateLevelToggles = (
  audioTime: number,
  currentLevelId: number,
  levelTogglesRef: React.MutableRefObject<LevelToggles>
) => {
  // Level 1 toggles logic
  if (currentLevelId === 1) {
    if (audioTime < 15) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: false,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false
      };
    }
    else if (audioTime >= 10 && audioTime < 11) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: false,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: false,
        showBubbles: false,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 11 && audioTime < 26) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: false,
        showBubbles: false,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 26 && audioTime < 62) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: false,
        showOilSplats: true,
        showHooks: false,
        showVisualizer: false,
        showBubbles: false,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 62 && audioTime < 80) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: false,
        showBottles: true,
        showOilSplats: true,
        showHooks: false,
        showVisualizer: false,
        showBubbles: false,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 80 && audioTime < 105) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: false,
        showBottles: true,
        showOilSplats: true,
        showHooks: false,
        showVisualizer: true,
        showBubbles: false,
        showBackgroundPattern: true,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 105 && audioTime < 234) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: true,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: true,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 234 && audioTime < 265) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: false,
        showHooks: true,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: false,
        showToothbrushes: true,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 265 && audioTime < 300) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: true,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: true,
        showRubberDuckies: false,
      };
    }
    else if (audioTime >= 300 && audioTime < 330) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: true,
        showHooks: true,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: true,
        showToothbrushes: true,
        showHotdogs: true,
        showRubberDuckies: true,
      };
    }
    else if (audioTime >= 330 && audioTime < 390) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: true,
        showToothbrushes: true,
        showHotdogs: true,
        showRubberDuckies: true,
      };
    }
    else if (audioTime >= 390 && audioTime < 410) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: true,
        showOilSplats: true,
        showHooks: true,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: true,
        showToothbrushes: true,
        showHotdogs: true,
        showRubberDuckies: true,
      };
    }
    else if (audioTime >= 410) {
      levelTogglesRef.current = {
        showFlora: true,
        showBags: true,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
      };
    }
  }
  // Level 2 toggles logic - match the narrative timing
  else if (currentLevelId === 2) {
    if (audioTime < 28) {
      levelTogglesRef.current = {
        showFlora: false,
        showBags: false,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
        // Level 2 specific obstacle toggles
        showBuses: false,
        showBats: false,
        showChickens: false
      };
    }
    else if (audioTime >= 28 && audioTime < 36) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: false,
        showBats: false,
        showChickens: false
      };
    }
    else if (audioTime >= 36 && audioTime < 49) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: false,
        showBats: false,
        showChickens: false
      };
    }
    else if (audioTime >= 49 && audioTime < 83) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showBats: false,
        showChickens: false
      };
    }
    else if (audioTime >= 83 && audioTime < 120) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showChickens: true,
        showBats: false
      };
    }
    else if (audioTime >= 120 && audioTime < 173) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showChickens: true,
        showBats: true
      };
    }
    else if (audioTime >= 173 && audioTime < 252) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showChickens: true,
        showBats: true,
      };
    }
    else if (audioTime >= 252 && audioTime < 301) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showChickens: true,
        showBats: true,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
      };
    }
    else if (audioTime >= 301) {
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showBuses: true,
        showChickens: true,
        showBats: true,
        showVisualizer: true,
        showBubbles: true,
        showBackgroundPattern: true,
      };
    }
  }
  // Level 3 toggles logic
  else if (currentLevelId === 3) {
    if (audioTime < 3) {
      levelTogglesRef.current = {
        showFlora: false,
        showBags: false,
        showBottles: false,
        showOilSplats: false,
        showHooks: false,
        showVisualizer: true,
        showBubbles: false,
        showBackgroundPattern: false,
        showFlipFlops: false,
        showToothbrushes: false,
        showHotdogs: false,
        showRubberDuckies: false,
        // Level 3 specific toggles
        showClouds: false,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 3 && audioTime < 30) {
      // Cloud video rises
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 30 && audioTime < 71) {
      // First clouds float by
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 71 && audioTime < 90) {
      // The first mushrooms come
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: true,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 90 && audioTime < 125) {
      // Less Clouds
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: true,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 125 && audioTime < 150) {
      // Now just Mushrooms
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: false,
        showMushrooms: true,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 150 && audioTime < 165) {
      // Clouds return
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 165 && audioTime < 185) {
      // Clouds are now darker - storm is brewing
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: true
      };
    }
    else if (audioTime >= 185 && audioTime < 210) {
      // THE CAVE - with storm clouds and lightning
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: false,
        showTrippyObjects: false,
        showStormEffects: true
      };
    }
    else if (audioTime >= 210 && audioTime < 230) {
      // Here come the Black Headed Gulls
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: true,
        showTrippyObjects: false,
        showStormEffects: true
      };
    }
    else if (audioTime >= 230 && audioTime < 270) {
      // Add Bald Eagles
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: false,
        showEagles: true,
        showTrippyObjects: false,
        showStormEffects: true
      };
    }
    else if (audioTime >= 270 && audioTime < 304) {
      // Exit the cave - mushrooms return
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: false,
        showMushrooms: true,
        showEagles: true,
        showTrippyObjects: false,
        showStormEffects: false
      };
    }
    else if (audioTime >= 304) {
      // Trippy section
      levelTogglesRef.current = {
        ...levelTogglesRef.current,
        showClouds: true,
        showMushrooms: true,
        showEagles: false,
        showTrippyObjects: true,
        showStormEffects: false
      };
    }
  }
};

/**
 * Process color transition events
 */
export const processColorEvents = (
  audioTime: number,
  colorEvents: any,
  activeColorTransition: any,
  backgroundColorRef: React.MutableRefObject<string>,
  waveColorRef: React.MutableRefObject<string>
) => {
  // Ensure colorEvents is initialized as an array
  const eventsArray = Array.isArray(colorEvents) ? colorEvents : [];

  // Log warning if colorEvents is not an array
  if (!Array.isArray(colorEvents)) {
    console.error('colorEvents is not an array', colorEvents);
  }

  // Now safely iterate through the events
  eventsArray.forEach(event => {
    if (!event.triggered && audioTime >= event.timestamp) {
      console.log('processing color event (inside for loop): ', event, 'color: ', backgroundColorRef.current);
      event.triggered = true;
      activeColorTransition.backgroundColor = backgroundColorRef.current;
      activeColorTransition.waveColor = waveColorRef.current;
      activeColorTransition.progress = 0;
      activeColorTransition.targetBackgroundColor = event.backgroundColor;
      activeColorTransition.targetWaveColor = event.waveColor;
      activeColorTransition.transitionDuration = event.transitionDuration;
    }
  });
};

/**
 * Process level 2 specific events
 */
export const processLevel2Events = (
  audioTime: number,
  canvas: HTMLCanvasElement,
  level2TimedEvents: any,
  level2ObstacleImages: HTMLImageElement[],
  level2PickupImages: HTMLImageElement[],
  gameState: GameState
) => {
  level2TimedEvents.obstacles.forEach((event: any) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;

      if (!canvas) return;

      let img: HTMLImageElement | null = null;
      let width = 50;
      let height = 50;

      switch (event.type) {
        case 'bats':
          img = level2ObstacleImages[0] || null;
          width = 100;
          height = 100;
          break;
        case 'bus':
          img = level2ObstacleImages[1] || null;
          width = 200;
          height = 100;
          break;
        case 'chicken':
          img = level2ObstacleImages[2] || null;
          width = 100;
          height = 100;
          break;
      }

      if (img) {
        gameState.obstacles.push({
          x: canvas.width,
          y: getSpawnY(canvas, height),
          width,
          height,
          type: 'obstacle',
          speed: 1 + Math.random() * 2,
          rotation: event.type === 'bus' ? 0 : Math.random() * Math.PI * 2,
          pickupImage: img
        });
      }
    }
  });

  level2TimedEvents.pickups.forEach((event: any) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;

      if (!canvas) return;

      let img: HTMLImageElement | null = null;
      let width = 40;
      let height = 40;

      switch (event.type) {
        case 'vitaminC':
          img = level2PickupImages[0] || null;
          width = 60;
          height = 60;
          break;
        case 'pill':
          img = level2PickupImages[1] || null;
          width = 50;
          height = 70;
          break;
        case 'tumeric':
          img = level2PickupImages[2] || null;
          width = 60;
          height = 60;
          break;
        case 'ginger':
          img = level2PickupImages[3] || null;
          width = 60;
          height = 60;
          break;
      }

      if (img) {
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, height),
          width,
          height,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: img
        });

        gameState.trashStats.totalSpawned++;
      }
    }
  });
};

/**
 * Process level 3 specific events
 */
export const processLevel3Events = (
  audioTime: number,
  canvas: HTMLCanvasElement,
  level3TimedEvents: Level3TimedEvents,
  level3ObstacleImages: HTMLImageElement[],
  level3MushroomImages: HTMLImageElement[],
  level3TrippyImages: HTMLImageElement[],
  gameState: GameState
) => {
  // Process obstacles (eagles)
  level3TimedEvents.obstacles.forEach((event) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;

      if (!canvas) return;
      if (event.type === 'eagle') {
        const eagleImg = level3ObstacleImages.find(img => img.src.includes('eagle'));
        if (eagleImg) {
          gameState.obstacles.push({
            x: canvas.width,
            y: getSpawnY(canvas, 80),
            width: 100,
            height: 80,
            type: 'obstacle',
            speed: 2 + Math.random() * 2.5, // Eagles are faster
            rotation: 0,
            pickupImage: eagleImg
          });
        }
      }
      if (event.type === 'cloud') {
        const cloudImg = level3ObstacleImages.find(img => img.src.includes('clouds'));
        if (cloudImg) {
          // For rising clouds at beginning
          if (audioTime < 10) {
            gameState.obstacles.push({
              x: canvas.width * Math.random(), // Random x position
              y: canvas.height + 50, // Start off-screen at bottom
              width: 120,
              height: 80,
              type: 'obstacle',
              speed: -0.5 - Math.random(), // Negative speed means moving upward
              rotation: 0,
              pickupImage: cloudImg,
              baseY: canvas.height + 50 // Store initial Y for animations
            });
          }
          else {
            gameState.obstacles.push({
              x: canvas.width,
              y: getSpawnY(canvas, 80),
              width: 120 + Math.random() * 80, // Variable size
              height: 80 + Math.random() * 40,
              type: 'obstacle',
              speed: 0.5 + Math.random() * 1.5, // Slow moving
              rotation: 0,
              pickupImage: cloudImg
            });
          }
        }
      }
    }
  });

  // Process pickups (mushrooms)
  level3TimedEvents.pickups.forEach((event) => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;

      if (!canvas) return;

      if (event.type === 'mushroom' && level3MushroomImages.length > 0) {
        // Select mushroom variant if specified, otherwise random
        let index = 0;
        if (event.variant) {
          index = parseInt(event.variant, 10) - 1;
          if (isNaN(index) || index < 0 || index >= level3MushroomImages.length) {
            index = Math.floor(Math.random() * level3MushroomImages.length);
          }
        } else {
          index = Math.floor(Math.random() * level3MushroomImages.length);
        }

        const mushroomImg = level3MushroomImages[index];
        if (mushroomImg) {
          gameState.pickups.push({
            x: canvas.width,
            y: getSpawnY(canvas, 60),
            width: 60,
            height: 60,
            type: 'trash',
            speed: 1 + Math.random() * 2,
            rotation: Math.random() * Math.PI * 2,
            pickupImage: mushroomImg
          });
          gameState.trashStats.totalSpawned++;
        }
      }
      if (event.type === 'trippy' && level3TrippyImages.length > 0) {
        // Select specific trippy object if variant specified
        let trippyImg;
        if (event.variant) {
          const variant = event.variant; // Assign to const to make TypeScript happy
          trippyImg = level3TrippyImages.find(img => img.src.includes(variant));
        }

        // Fallback to random if not found or not specified
        if (!trippyImg) {
          trippyImg = level3TrippyImages[Math.floor(Math.random() * level3TrippyImages.length)];
        }

        if (trippyImg) {
          // In the trippy section, objects can be anywhere in the screen
          // They also change size and move in random patterns
          const size = 50 + Math.random() * 100; // Random size for trippy effect
          const speed = 0.5 + Math.random() * 2;

          gameState.pickups.push({
            x: canvas.width,
            y: Math.random() * (canvas.height - 100) + 50, // Anywhere on screen
            width: size,
            height: size,
            type: 'trash',
            speed: speed,
            rotation: Math.random() * Math.PI * 2,
            pickupImage: trippyImg
          });
        }
      }
    }
  });
};

/**
 * Spawn items on beat detection
 */
export const spawnItemsOnBeat = (
  canvas: HTMLCanvasElement,
  levelToggles: LevelToggles,
  gameState: GameState,
  currentLevelId: number,
  audioProgress: number,
  waterBottleImage: HTMLImageElement | null,
  plasticBagImage: HTMLImageElement | null,
  oilSplatImage: HTMLImageElement | null,
  fishHookImage: HTMLImageElement | null,
  flipflopImage: HTMLImageElement | null,
  toothbrushImage: HTMLImageElement | null,
  hotdogImage: HTMLImageElement | null,
  rubberDuckyImage: HTMLImageElement | null,
  level2PickupImages: HTMLImageElement[],
  level2ObstacleImages: HTMLImageElement[],
  level3ObstacleImages: HTMLImageElement[] = [],
  level3MushroomImages: HTMLImageElement[] = [],
  level3TrippyImages: HTMLImageElement[] = []
) => {
  console.log(`[DEBUG] spawnItemsOnBeat called - Level: ${currentLevelId}, LevelToggles:`,
    JSON.stringify({
      showBottles: levelToggles.showBottles,
      showBags: levelToggles.showBags,
      showOilSplats: levelToggles.showOilSplats,
      showHooks: levelToggles.showHooks
    })
  );

  //console.log(`[DEBUG] Images loaded - waterBottle: ${!!waterBottleImage}, plasticBag: ${!!plasticBagImage}, obstacle: ${!!oilSplatImage}, fishHook: ${!!fishHookImage}`);

  if (currentLevelId === 1) {
    // Level 1 spawning logic remains unchanged

    // Spawn water bottles
    if (levelToggles.showBottles && waterBottleImage) {
      const spawnChance = 0.075 + (audioProgress / 200);
      const roll = Math.random();
      console.log(`[DEBUG] Water bottle spawn check - chance: ${spawnChance.toFixed(3)}, roll: ${roll.toFixed(3)}, willSpawn: ${roll < spawnChance}`);

      if (roll < spawnChance) {
        console.log('[DEBUG] 🍶 Spawning water bottle');
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 30,
          height: 50,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: waterBottleImage
        });
        gameState.trashStats.totalSpawned++;
      }
    } else if (levelToggles.showBottles) {
      console.log('[DEBUG] ❌ Cannot spawn water bottle - image is null');
    }

    // Spawn plastic bags
    if (levelToggles.showBags && plasticBagImage) {
      const spawnChance = 0.075 + (audioProgress / 200);
      const roll = Math.random();
      console.log(`[DEBUG] Plastic bag spawn check - chance: ${spawnChance.toFixed(3)}, roll: ${roll.toFixed(3)}, willSpawn: ${roll < spawnChance}`);

      if (roll < spawnChance) {
        console.log('[DEBUG] 👜 Spawning plastic bag');
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 30,
          height: 50,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: plasticBagImage
        });
        gameState.trashStats.totalSpawned++;
      }
    } else if (levelToggles.showBags) {
      console.log('[DEBUG] ❌ Cannot spawn plastic bag - image is null');
    }

    // Spawn obstacles
    if (levelToggles.showOilSplats && oilSplatImage) {
      const spawnChance = 0.075 + (audioProgress / 200);
      const roll = Math.random();
      console.log(`[DEBUG] Obstacle spawn check - chance: ${spawnChance.toFixed(3)}, roll: ${roll.toFixed(3)}, willSpawn: ${roll < spawnChance}`);

      if (roll < spawnChance) {
        console.log('[DEBUG] 🪨 Spawning obstacle');
        gameState.obstacles.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 50,
          height: 50,
          type: 'obstacle',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: oilSplatImage
        });
      }
    } else if (levelToggles.showOilSplats) {
      console.log('[DEBUG] ❌ Cannot spawn obstacle - image is null');
    }

    // Spawn fish hooks
    if (levelToggles.showHooks && fishHookImage) {
      const roll = Math.random();
      console.log(`[DEBUG] Fishhook spawn check - chance: 0.5, roll: ${roll.toFixed(3)}, willSpawn: ${roll < 0.5}`);

      if (roll < 0.5) {
        console.log('[DEBUG] 🪝 Spawning fishhook');
        const fishhookY = canvas.height * (0.1 + Math.random() * 0.4);
        gameState.obstacles.push({
          x: canvas.width,
          y: fishhookY,
          width: 50,
          height: 150,
          type: 'fishhook',
          speed: 1 + Math.random() * 2,
          pickupImage: fishHookImage
        });
      }
    } else if (levelToggles.showHooks) {
      console.log('[DEBUG] ❌ Cannot spawn fishhook - image is null');
    }

    // Spawn special trash items (flipflops, toothbrushes, hotdogs, rubber duckies)
    if (levelToggles.showFlipFlops) {
      spawnSpecialTrashItem(
        canvas,
        gameState,
        currentLevelId,
        'flipflop',
        0.03,
        flipflopImage,
        level2PickupImages,
        30,
        50
      );
    }

    if (levelToggles.showToothbrushes) {
      spawnSpecialTrashItem(
        canvas,
        gameState,
        currentLevelId,
        'toothbrush',
        0.03,
        toothbrushImage,
        level2PickupImages,
        10,
        40
      );
    }

    if (levelToggles.showHotdogs) {
      spawnSpecialTrashItem(
        canvas,
        gameState,
        currentLevelId,
        'hotdog',
        0.03,
        hotdogImage,
        level2PickupImages,
        50,
        25
      );
    }

    if (levelToggles.showRubberDuckies) {
      spawnSpecialTrashItem(
        canvas,
        gameState,
        currentLevelId,
        'rubberducky',
        0.03,
        rubberDuckyImage,
        level2PickupImages,
        50,
        50
      );
    }
  } else if (currentLevelId === 2) {
    // Level 2 spawning logic limited to:
    // • Pickups: vitaminC, tumeric, ginger
    // • Obstacles: buses, bats, chickens

    // Spawn vitaminC pickup from index 0
    if (levelToggles.showBottles && level2PickupImages.length > 0 && level2PickupImages[0]) {
      if (Math.random() < 0.075 + (audioProgress / 200)) {
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 60,
          height: 60,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: level2PickupImages[0]
        });
        gameState.trashStats.totalSpawned++;
      }
    }

    // Spawn ginger pickup from index 3
    if (levelToggles.showBags && level2PickupImages.length > 3 && level2PickupImages[3]) {
      if (Math.random() < 0.075 + (audioProgress / 200)) {
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 60,
          height: 60,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: level2PickupImages[3]
        });
        gameState.trashStats.totalSpawned++;
      }
    }

    // Spawn tumeric pickup from index 2
    if (level2PickupImages.length > 2 && level2PickupImages[2]) {
      if (Math.random() < 0.05 + (audioProgress / 200)) {
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, 50),
          width: 60,
          height: 60,
          type: 'trash',
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: level2PickupImages[2]
        });
        gameState.trashStats.totalSpawned++;
      }
    }

    // Spawn obstacles: only buses, bats, and chickens
    if (levelToggles.showOilSplats && level2ObstacleImages.length > 0) {
      const baseProbability = 0.075 + (audioProgress / 200);
      let availableObstacles: { img: HTMLImageElement, type: string, width: number, height: number }[] = [];

      // Bus obstacle (index 0)
      if (levelToggles.showBuses && level2ObstacleImages.length > 0 && level2ObstacleImages[0]) {
        availableObstacles.push({
          img: level2ObstacleImages[0],
          type: 'bus',
          width: 100,
          height: 60
        });
      }

      // Chicken obstacle (index 2)
      if (levelToggles.showChickens && level2ObstacleImages.length > 2 && level2ObstacleImages[2]) {
        availableObstacles.push({
          img: level2ObstacleImages[2],
          type: 'chicken',
          width: 60,
          height: 60
        });
      }

      // Bats obstacle (index 1)
      if (levelToggles.showBats && level2ObstacleImages.length > 1 && level2ObstacleImages[1]) {
        if (audioProgress > 301 / 420) {
          for (let i = 0; i < 3; i++) {
            if (Math.random() < 0.6) {
              gameState.obstacles.push({
                x: canvas.width + (Math.random() * 100),
                y: getSpawnY(canvas, 100),
                width: 60,
                height: 60,
                type: 'obstacle',
                speed: 2 + Math.random() * 3,
                rotation: Math.random() * Math.PI * 2,
                pickupImage: level2ObstacleImages[1]
              });
            }
          }
        } else {
          availableObstacles.push({
            img: level2ObstacleImages[1],
            type: 'bats',
            width: 60,
            height: 60
          });
        }
      }

      if (availableObstacles.length > 0 && Math.random() < baseProbability) {
        const selectedObstacle = availableObstacles[Math.floor(Math.random() * availableObstacles.length)];
        gameState.obstacles.push({
          x: canvas.width,
          y: getSpawnY(canvas, selectedObstacle.height),
          width: selectedObstacle.width,
          height: selectedObstacle.height,
          type: 'obstacle',
          speed: 1 + Math.random() * 2,
          rotation: selectedObstacle.type === 'bus' ? 0 : Math.random() * Math.PI * 2,
          pickupImage: selectedObstacle.img
        });
      }
    }
  } else if (currentLevelId === 3) {
    // Level 3 spawning logic
    console.log(`[DEBUG] Level 3 spawning logic - audioProgress: ${audioProgress}, levelToggles:`, levelToggles, 'level3MushroomImages:', level3MushroomImages, 'level3ObstacleImages:', level3ObstacleImages);
    // Spawn mushrooms on beat when the toggle is active
    if (levelToggles.showMushrooms && level3MushroomImages?.length > 0) {
      const spawnChance = 0.1 + (audioProgress / 150); // Higher chance than level 1/2 items

      if (Math.random() < spawnChance) {
        // Select a random mushroom image
        const mushroomIndex = Math.floor(Math.random() * level3MushroomImages.length);
        const mushroomImg = level3MushroomImages[mushroomIndex];

        if (mushroomImg) {
          gameState.pickups.push({
            x: canvas.width,
            y: getSpawnY(canvas, 60),
            width: 60,
            height: 60,
            type: 'trash',
            speed: 1 + Math.random() * 2,
            rotation: Math.random() * Math.PI * 2,
            pickupImage: mushroomImg
          });
          gameState.trashStats.totalSpawned++;
        }
      }
    }

    // Spawn trippy objects during the trippy section (after timestamp 304)
    if (levelToggles.showTrippyObjects && level3TrippyImages?.length > 0) {
      // Higher chance during the trippy section
      const spawnChance = 0.15 + (audioProgress / 100);

      if (Math.random() < spawnChance) {
        const trippyIndex = Math.floor(Math.random() * level3TrippyImages.length);
        const trippyImg = level3TrippyImages[trippyIndex];

        if (trippyImg) {
          // Random size for trippy effect
          const size = 50 + Math.random() * 100;

          // Add warping property to trippy pickups
          gameState.pickups.push({
            x: canvas.width,
            y: Math.random() * (canvas.height - 100) + 50, // Anywhere on screen
            width: size,
            height: size,
            type: 'trash',
            speed: 0.5 + Math.random() * 2,
            rotation: Math.random() * Math.PI * 2,
            pickupImage: trippyImg,
            // Add custom properties for warping effect
            warpFactor: 0.5 + Math.random() * 0.5,
            warpSpeed: 0.1 + Math.random() * 0.3,
            warpOffset: Math.random() * Math.PI * 2
          });
          gameState.trashStats.totalSpawned++;
        }
      }
    }

    //spawn clouds if showClouds is true
    if (levelToggles.showClouds && level3ObstacleImages?.length > 0) {
      const spawnChance = 0.05 + (audioProgress / 150);

      if (Math.random() < spawnChance) {
        const cloudImg = level3ObstacleImages.find(img => img.src.includes('clouds'));
        console.log('spawning cloud - cloudImg', cloudImg);
        if (cloudImg) {
          gameState.obstacles.push({
            x: canvas.width,
            y: getSpawnY(canvas, 80),
            width: 80 + Math.random() * 80,
            height: 40 + Math.random() * 40,
            type: 'obstacle',
            speed: 0.5 + Math.random() * 1.5,
            rotation: 0,
            pickupImage: cloudImg
          });
        }
      }
    }

    //spawn eagles if showEagles is true
    if (levelToggles.showEagles && level3ObstacleImages?.length > 0) {
      const spawnChance = 0.1 + (audioProgress / 150);

      if (Math.random() < spawnChance) {
        const eagleImg = level3ObstacleImages.find(img => img.src.includes('eagle'));

        if (eagleImg) {
          gameState.obstacles.push({
            x: canvas.width,
            y: getSpawnY(canvas, 80),
            width: 100,
            height: 80,
            type: 'obstacle',
            speed: 1 + Math.random() * 2,
            rotation: 0,
            pickupImage: eagleImg
          });
        }
      }
    }
  }
};

export const spawnSpecialTrashItem = (
  canvas: HTMLCanvasElement,
  gameState: GameState,
  currentLevelId: number,
  type: 'flipflop' | 'toothbrush' | 'hotdog' | 'rubberducky',
  probability: number,
  image: HTMLImageElement | null,
  level2PickupImages: HTMLImageElement[],
  width: number,
  height: number
) => {
  if (currentLevelId === 2) {
    if (level2PickupImages.length > 0) {
      if (Math.random() < probability) {
        const randomPickup = level2PickupImages[Math.floor(Math.random() * level2PickupImages.length)];
        gameState.pickups.push({
          x: canvas.width,
          y: getSpawnY(canvas, height),
          width,
          height,
          type,
          speed: 1 + Math.random() * 2,
          rotation: Math.random() * Math.PI * 2,
          pickupImage: randomPickup
        });
        gameState.trashStats.totalSpawned++;
      }
    }
  }
  else if (image) {
    if (Math.random() < probability) {
      gameState.pickups.push({
        x: canvas.width,
        y: getSpawnY(canvas, height),
        width,
        height,
        type,
        speed: 1 + Math.random() * 2,
        rotation: Math.random() * Math.PI * 2,
        pickupImage: image
      });
      gameState.trashStats.totalSpawned++;
    }
  }
};
/**
 * Update and check collisions for trash items
 */
export const updateAndCheckTrashCollisions = (
  ctx: CanvasRenderingContext2D,
  gameState: GameState,
  factor: number,
  speedMultiplier: number,
  pulse: number,
  getMultiplierFromStreak: (streak: number) => number,
  setHealth: (callback: (prev: number) => number) => void,
  pickupSound: HTMLAudioElement | null
) => {
  for (let i = gameState.pickups.length - 1; i >= 0; i--) {
    const item = gameState.pickups[i];

    // Update position
    item.x -= item.speed * speedMultiplier * factor;

    // Remove if off screen
    if (item.x + item.width * pulse < 0) {
      gameState.trashStats.missed++;
      gameState.pickups.splice(i, 1);
      continue;
    }

    // Check collision with player
    const effectiveWidth = item.width * pulse;
    const effectiveHeight = item.height * pulse;

    if (
      gameState.player.x < item.x + effectiveWidth &&
      gameState.player.x + gameState.player.width > item.x &&
      gameState.player.y < item.y + effectiveHeight &&
      gameState.player.y + gameState.player.height > item.y
    ) {
      const streak = gameState.streak + 1;
      const multiplier = getMultiplierFromStreak(streak);
      const points = 10 * multiplier;

      gameState.streak = streak;
      gameState.multiplier = multiplier;
      gameState.highestStreak = Math.max(gameState.highestStreak, streak);
      gameState.score += points;
      gameState.trashStats.collected++;

      const popupX = item.x + effectiveWidth / 2;
      const popupY = item.y + effectiveHeight / 2;
      const scoreText = multiplier > 1 ? `+${points} (${multiplier}x)` : `+${points}`;

      gameState.scorePopups.push({
        x: popupX,
        y: popupY,
        text: scoreText,
        opacity: 1,
        lifetime: 100
      });

      if (streak % 5 === 0 && ctx.canvas) {
        gameState.scorePopups.push({
          x: ctx.canvas.width / 2,
          y: ctx.canvas.height / 2,
          text: `${streak} STREAK! ${multiplier}x MULTIPLIER!`,
          opacity: 1,
          lifetime: 120
        });
      }

      if (item.pickupImage &&
        (item.pickupImage === window.waterBottleRef?.current ||
          item.pickupImage === window.plasticBagRef?.current)) {
        createParticles(gameState.particles, item.x, item.y, '#FFC0CB', 20, 'heart');
        createParticles(gameState.particles, item.x, item.y, '#1489CF', 20, 'heart');
      } else {
        createParticles(gameState.particles, item.x, item.y, getParticleColorFromStreak(streak), 20);
      }

      gameState.pickups.splice(i, 1);

      setHealth(prev => Math.min(100, prev + 1));

      // Check if sound is properly initialized before playing
      if (pickupSound && pickupSound.readyState >= 2) {
        pickupSound.play().catch(error => {
          console.warn("Error playing pickup sound:", error);
        });
      }

      continue;
    } else {
      drawItem(ctx, item, pulse);
    }
  }
};

/**
 * Update and check collisions for obstacles
 */
export const updateAndCheckObstacleCollisions = (
  ctx: CanvasRenderingContext2D,
  gameState: GameState,
  audioTime: number,
  songDuration: number,
  factor: number,
  speedMultiplier: number,
  setScore: (value: number) => void,
  setHealth: (callback: (prev: number) => number) => void,
  hitSound: HTMLAudioElement | null,
  setLevelEnded: (value: boolean) => void,
  gameLoopRef: React.MutableRefObject<boolean>,
  animationFrameIdRef: React.MutableRefObject<number | null>
) => {
  for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
    const item = gameState.obstacles[i];

    item.x -= item.speed * speedMultiplier * factor;

    if (audioTime >= songDuration * 0.5 && item.baseY !== undefined) {
      const bobbingOffset = Math.sin(Date.now() / 200) * 10;
      item.y = item.baseY + bobbingOffset;
    }

    if (item.x + item.width < 0) {
      gameState.obstacles.splice(i, 1);
      continue;
    }

    if (item.type === 'fishhook') {
      const hookLeft = item.x;
      const hookRight = item.x + item.width;
      const hookTop = item.y + item.height / 2;
      const hookBottom = item.y + item.height;
      const player = gameState.player;

      if (
        player.x < hookRight &&
        player.x + player.width > hookLeft &&
        player.y < hookBottom &&
        player.y + player.height > hookTop
      ) {
        handleObstacleCollision(
          gameState,
          item,
          setScore,
          setHealth,
          hitSound,
          setLevelEnded,
          gameLoopRef,
          animationFrameIdRef
        );

        gameState.obstacles.splice(i, 1);
        continue;
      } else {
        drawItem(ctx, item, 1);
      }
    } else {
      if (
        gameState.player.x < item.x + item.width &&
        gameState.player.x + gameState.player.width > item.x &&
        gameState.player.y < item.y + item.height &&
        gameState.player.y + gameState.player.height > item.y
      ) {
        handleObstacleCollision(
          gameState,
          item,
          setScore,
          setHealth,
          hitSound,
          setLevelEnded,
          gameLoopRef,
          animationFrameIdRef
        );

        gameState.obstacles.splice(i, 1);
        continue;
      } else {
        drawItem(ctx, item, 1);
      }
    }
  }
};

/**
 * Handle collision with an obstacle
 */
export const handleObstacleCollision = (
  gameState: GameState,
  item: any,
  setScore: (value: number) => void,
  setHealth: (callback: (prev: number) => number) => void,
  hitSound: HTMLAudioElement | null,
  setLevelEnded: (value: boolean) => void,
  gameLoopRef: React.MutableRefObject<boolean>,
  animationFrameIdRef: React.MutableRefObject<number | null>
) => {
  gameState.score = Math.max(0, gameState.score - 20);
  setScore(gameState.score);

  gameState.streak = 0;
  gameState.multiplier = 1;

  const popupX = item.x + item.width / 2;
  const popupY = item.y + item.height / 2;
  gameState.scorePopups.push({
    x: popupX,
    y: popupY,
    text: "-20",
    opacity: 1,
    lifetime: 100
  });

  const particleColor = '#000000';
  createParticles(gameState.particles, item.x, item.y, particleColor, 20);

  // Check if sound is properly initialized before playing
  if (hitSound && hitSound.readyState >= 2) {
    hitSound.play().catch(error => {
      console.warn("Error playing hit sound:", error);
    });
  }

  gameState.player.spinRotation = item.type === 'fishhook' ? Math.PI * 4 : -Math.PI * 4;
  gameState.player.hitTime = Date.now();
  gameState.player.hitType = item.type;

  setHealth(prev => {
    const newHealth = prev - 10;
    if (newHealth <= 0) {
      setLevelEnded(true);
      gameLoopRef.current = false;
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = null;
      }
    }
    return newHealth;
  });
};

================
File: src/components/Game/GameLoop.ts
================
import { GameState, LevelToggles, ActiveTimedText, TimedTextEvent, TimedColorEvent, Level2TimedEvents, Level3TimedEvents, ActiveColor, Bubble, StreakDisplay, Level, CaveState } from '../../types';
import { getMultiplierFromStreak, interpolateColor } from '../../utils/colorUtils';
import { drawBackground, updateAndDrawBubbles, updateAndDrawScorePopups, updateAndDrawTimedTexts } from './BackgroundEffects';
import { drawFlora } from './Flora';
import { drawPlayer, updatePlayerPosition } from './Player';
import { createSwimParticles, updateAndDrawParticles } from './ParticleEffects';
import { updateCaveBoundaries, drawCaveEffect, checkCaveCollision, calculateCaveProximityScore } from './CaveEffects';
import { processColorEvents, processLevel2Events, processLevel3Events, spawnItemsOnBeat, updateAndCheckObstacleCollisions, updateAndCheckTrashCollisions, updateLevelToggles } from './GameHelpers';

// Use a constant top buffer to ensure nothing spawns behind the hearts
const TOP_BUFFER = 80;

// Get a random Y position for spawning items
export const getSpawnY = (canvas: HTMLCanvasElement | null, itemHeight: number): number => {
  if (!canvas) return TOP_BUFFER;
  return TOP_BUFFER + Math.random() * (canvas.height - TOP_BUFFER - itemHeight);
};

// Draw a game item (trash, obstacle, etc)
export const drawItem = (ctx: CanvasRenderingContext2D, item: any, pulse: number) => {
  ctx.save();
  
  if (
    (item.type === 'trash' ||
      item.type === 'flipflop' ||
      item.type === 'toothbrush' ||
      item.type === 'hotdog' ||
      item.type === 'rubberducky') && item.pickupImage
  ) {
    // Rotate trash items for visual interest
    item.rotation = (item.rotation || 0) + 0.0125;
    
    // Calculate dimensions preserving aspect ratio
    const aspect = item.pickupImage!.naturalWidth / item.pickupImage!.naturalHeight;
    const effectiveWidth = item.width * pulse;
    const effectiveHeight = effectiveWidth / aspect;
    
    // Draw with rotation
    const centerX = item.x + effectiveWidth / 2;
    const centerY = item.y + effectiveHeight / 2;
    ctx.translate(centerX, centerY);
    ctx.rotate(item.rotation!);
    ctx.drawImage(item.pickupImage, -effectiveWidth / 2, -effectiveHeight / 2, effectiveWidth, effectiveHeight);
  } 
  else if (item.type === 'obstacle' && item.pickupImage) {
    // Check if the item is a cloud or a bus (which shouldn't rotate)
    const isCloud = item.pickupImage.src.includes('clouds');
    const isBus = item.pickupImage.src.includes('bus');
    
    const effectiveWidth = item.width, effectiveHeight = item.height;
    const centerX = item.x + effectiveWidth / 2, centerY = item.y + effectiveHeight / 2;
    
    // Only rotate if it's not a cloud or bus
    if (!isCloud && !isBus) {
      item.rotation = (item.rotation || 0) + 0.0125;
      ctx.translate(centerX, centerY);
      ctx.rotate(item.rotation!);
      ctx.drawImage(item.pickupImage, -effectiveWidth / 2, -effectiveHeight / 2, effectiveWidth, effectiveHeight);
    } else {
      // Draw without rotation for clouds and buses
      ctx.translate(centerX, centerY);
      ctx.drawImage(item.pickupImage, -effectiveWidth / 2, -effectiveHeight / 2, effectiveWidth, effectiveHeight);
    }
  } 
  else if (item.type === 'fishhook' && item.pickupImage) {
    // Handle fishhooks
    const effectiveWidth = item.width, effectiveHeight = item.height;
    const centerX = item.x + effectiveWidth / 2, centerY = item.y + effectiveHeight / 2;
    ctx.drawImage(item.pickupImage, centerX - effectiveWidth / 2, centerY - effectiveHeight / 2, effectiveWidth, effectiveHeight);
  } 
  else {
    // Fallback red rectangle for missing images
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(0, 0, item.width, item.height);
  }
  
  ctx.restore();
};

// Main game loop
export const gameLoop = (
  canvasRef: React.RefObject<HTMLCanvasElement>,
  gameStateRef: React.MutableRefObject<GameState>,
  lastFrameTimeRef: React.MutableRefObject<number>,
  gameLoopRef: React.MutableRefObject<boolean>,
  animationFrameIdRef: React.MutableRefObject<number | null>,
  
  // Audio and input
  audioRef: React.RefObject<HTMLAudioElement>,
  audioProgressRef: React.MutableRefObject<number>,
  getAverageAmplitude: () => number,
  detectBeat: (amplitude: number, lastBeatTimeRef: React.MutableRefObject<number>) => boolean,
  lastBeatTimeRef: React.MutableRefObject<number>,
  inputRef: React.MutableRefObject<{ isTouching: boolean; touchY: number; isDesktop: boolean }>,
  
  // Visuals
  backgroundColorRef: React.MutableRefObject<string>,
  waveColorRef: React.MutableRefObject<string>,
  activeColorTransitionRef: React.MutableRefObject<ActiveColor>,
  bgPatternBubblesRef: React.MutableRefObject<Bubble[]>,
  levelTogglesRef: React.MutableRefObject<LevelToggles>,
  bubblesRef: React.MutableRefObject<Bubble[]>,
  amplitudeRef: React.MutableRefObject<number>,
  activeTimedTextsRef: React.MutableRefObject<ActiveTimedText[]>,
  floraItemsRef: React.MutableRefObject<any[]>,
  streakDisplayRef: React.MutableRefObject<StreakDisplay>,
  
  // Images
  fishImageRef: React.RefObject<HTMLImageElement>,
  waterBottleRef: React.RefObject<HTMLImageElement>,
  plasticBagRef: React.RefObject<HTMLImageElement>,
  oilSplatImageRef: React.RefObject<HTMLImageElement>,
  fishHookRef: React.RefObject<HTMLImageElement>,
  flipflopRef: React.RefObject<HTMLImageElement>,
  toothbrushRef: React.RefObject<HTMLImageElement>,
  hotdogRef: React.RefObject<HTMLImageElement>,
  rubberDuckyRef: React.RefObject<HTMLImageElement>,
  level2ObstacleImagesRef: React.MutableRefObject<HTMLImageElement[]>,
  level2PickupImagesRef: React.MutableRefObject<HTMLImageElement[]>,
  level3ObstacleImagesRef: React.MutableRefObject<HTMLImageElement[]>,
  level3MushroomImagesRef: React.MutableRefObject<HTMLImageElement[]>,
  level3TrippyImagesRef: React.MutableRefObject<HTMLImageElement[]>,
  
  // Level data
  currentLevelRef: React.MutableRefObject<Level>,
  timedTextEventsRef: React.MutableRefObject<TimedTextEvent[]>,
  colorEventsRef: React.MutableRefObject<TimedColorEvent[]>,
  level2TimedEventsRef: React.MutableRefObject<Level2TimedEvents>,
  level3TimedEventsRef: React.MutableRefObject<Level3TimedEvents>,
  caveRef: React.MutableRefObject<CaveState>,
  speedMultiplier: React.MutableRefObject<number>,
  
  // Game state setters
  setScore: (value: number) => void,
  setHealth: (callback: (prev: number) => number) => void,
  setLevelEnded: (value: boolean) => void,
  
  // Collision handling
  lastCollisionTimeRef: React.MutableRefObject<number>,
  lastProximityScoreTimeRef: React.MutableRefObject<number>,
  
  // Sound effects
  pickupSoundRef: React.RefObject<HTMLAudioElement>,
  hitSoundRef: React.RefObject<HTMLAudioElement>
) => {
  if (!gameLoopRef.current || !canvasRef.current) return;
  const ctx = canvasRef.current.getContext('2d');
  if (!ctx) return;
  const nowTime = performance.now();
  const deltaTime = (nowTime - lastFrameTimeRef.current) / 1000;
  lastFrameTimeRef.current = nowTime;
  const factor = deltaTime * 120;
  const canvas = canvasRef.current;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const audioTime = audioRef.current?.currentTime || 0;
  const songDuration = audioRef.current?.duration || 1;
  updateLevelToggles(audioTime, currentLevelRef.current.id, levelTogglesRef);
  if (currentLevelRef.current.id === 2) {
    processLevel2Events(
      audioTime, 
      canvasRef.current, 
      level2TimedEventsRef.current, 
      level2ObstacleImagesRef.current,
      level2PickupImagesRef.current,
      gameStateRef.current
    );
  } else if (currentLevelRef.current.id === 3) {
    processLevel3Events(
      audioTime,
      canvasRef.current,
      level3TimedEventsRef.current,
      level3ObstacleImagesRef.current,
      level3MushroomImagesRef.current,
      level3TrippyImagesRef.current,
      gameStateRef.current
    );
  }
  processColorEvents(audioTime, colorEventsRef.current, activeColorTransitionRef.current, backgroundColorRef, waveColorRef);
  // Interpolate active color transition for background and wave colors
  if (activeColorTransitionRef.current.progress < 1) {
    activeColorTransitionRef.current.progress += factor / (activeColorTransitionRef.current.transitionDuration * 60);
    if (activeColorTransitionRef.current.progress > 1) activeColorTransitionRef.current.progress = 1;
    backgroundColorRef.current = interpolateColor(
      activeColorTransitionRef.current.backgroundColor,
      activeColorTransitionRef.current.targetBackgroundColor,
      activeColorTransitionRef.current.progress
    );
    waveColorRef.current = interpolateColor(
      activeColorTransitionRef.current.waveColor,
      activeColorTransitionRef.current.targetWaveColor,
      activeColorTransitionRef.current.progress
    );
  }
  const amplitude = getAverageAmplitude();
  amplitudeRef.current = amplitude;
  const pulse = 1 + amplitude / 100;
  const audioTimeMs = audioRef.current ? audioRef.current.currentTime * 1000 : 0;
  const levelStartDelay = 0;
  const effectiveTime = Math.max(0, audioTimeMs - levelStartDelay);
  speedMultiplier.current = 1 + ((effectiveTime / 1000) / 120) * 0.5;
  drawBackground(ctx, amplitude / 100, backgroundColorRef, currentLevelRef.current.id, levelTogglesRef.current.showBackgroundPattern, bgPatternBubblesRef);
  if (levelTogglesRef.current.showFlora) {
    drawFlora(ctx, floraItemsRef.current, amplitude, factor, speedMultiplier.current, currentLevelRef.current.id);
  }
  // Ensure timedTextEventsRef.current is an array
  const timedEvents = Array.isArray(timedTextEventsRef.current) ? timedTextEventsRef.current : [];
  
  // Now safely iterate through the events
  timedEvents.forEach(event => {
    if (!event.triggered && audioTime >= event.timestamp) {
      event.triggered = true;
      activeTimedTextsRef.current.push({ text: event.text, lifetime: event.lifetime ?? 200, color: event.color ?? 'black' });
    }
  });
  if (levelTogglesRef.current.showBubbles) {
    updateAndDrawBubbles(ctx, bubblesRef.current, amplitude, factor);
  }
  updateAndDrawTimedTexts(ctx, activeTimedTextsRef.current, factor);
  updatePlayerPosition(
    gameStateRef.current.player,
    inputRef.current.touchY,
    factor,
    inputRef.current.isDesktop || inputRef.current.isTouching
  );
  if (detectBeat(amplitude, lastBeatTimeRef)) {
    // Safely access currentLevel ID with a fallback to prevent undefined errors
    const currentLevelId = currentLevelRef?.current?.id || 1;
    
    spawnItemsOnBeat(
      canvas,
      levelTogglesRef.current,
      gameStateRef.current,
      currentLevelId,
      audioProgressRef.current,
      waterBottleRef.current,
      plasticBagRef.current,
      oilSplatImageRef.current,
      fishHookRef.current,
      flipflopRef.current,
      toothbrushRef.current,
      hotdogRef.current,
      rubberDuckyRef.current,
      level2PickupImagesRef.current,
      level2ObstacleImagesRef.current,
      level3ObstacleImagesRef.current,
      level3MushroomImagesRef.current,
      level3TrippyImagesRef.current,
    );
  }
  updateAndCheckTrashCollisions(
    ctx,
    gameStateRef.current,
    factor,
    speedMultiplier.current,
    pulse,
    getMultiplierFromStreak,
    setHealth,
    pickupSoundRef.current
  );
  updateAndCheckObstacleCollisions(
    ctx,
    gameStateRef.current,
    audioTime,
    songDuration,
    factor,
    speedMultiplier.current,
    setScore,
    setHealth,
    hitSoundRef.current,
    setLevelEnded,
    gameLoopRef,
    animationFrameIdRef
  );
  createSwimParticles(gameStateRef.current.particles, gameStateRef.current.player, gameStateRef.current.streak);
  updateAndDrawParticles(ctx, gameStateRef.current.particles, factor);
  updateAndDrawScorePopups(ctx, gameStateRef.current.scorePopups, factor);
  drawPlayer(ctx, gameStateRef.current.player, fishImageRef.current);
  const caveActive = currentLevelRef.current.isCaveMechanic || (currentLevelRef.current.id === 1 && audioTime >= 330 && audioTime < 390);
  if (caveActive) {
    const CAVE_WARNING_DURATION = 3;
    const isWarningPeriod = currentLevelRef.current.id === 1 && audioTime < 330 + CAVE_WARNING_DURATION;
    // Normalize amplitude for cave mode
    const normalizedAmplitude = amplitude / 100;
    updateCaveBoundaries(canvas, caveRef.current, normalizedAmplitude, inputRef.current.isDesktop);
    drawCaveEffect(ctx, caveRef.current, normalizedAmplitude, isWarningPeriod);
    calculateCaveProximityScore(
      gameStateRef.current.player,
      caveRef.current,
      lastProximityScoreTimeRef,
      (callback) => setScore(callback(gameStateRef.current.score)),
      gameStateRef.current.scorePopups
    );
    checkCaveCollision(
      gameStateRef.current.player,
      caveRef.current,
      isWarningPeriod,
      lastCollisionTimeRef,
      gameStateRef.current.particles,
      hitSoundRef.current,
      (callback) => setScore(callback(gameStateRef.current.score)),
      setHealth,
      gameStateRef.current.scorePopups,
      (value) => { gameStateRef.current.streak = value; },
      (value) => { gameStateRef.current.multiplier = value; },
      setLevelEnded,
      gameLoopRef,
      animationFrameIdRef
    );
  }
  setScore(gameStateRef.current.score);
  const streakScale = Math.min(3, 0.5 + (gameStateRef.current.streak / 50) + (amplitudeRef.current / 255) * 0.5);
  streakDisplayRef.current.scale = streakScale;
  animationFrameIdRef.current = requestAnimationFrame(() => gameLoop(
    canvasRef,
    gameStateRef,
    lastFrameTimeRef,
    gameLoopRef,
    animationFrameIdRef,
    audioRef,
    audioProgressRef,
    getAverageAmplitude,
    detectBeat,
    lastBeatTimeRef,
    inputRef,
    backgroundColorRef,
    waveColorRef,
    activeColorTransitionRef,
    bgPatternBubblesRef,
    levelTogglesRef,
    bubblesRef,
    amplitudeRef,
    activeTimedTextsRef,
    floraItemsRef,
    streakDisplayRef,
    fishImageRef,
    waterBottleRef,
    plasticBagRef,
    oilSplatImageRef,
    fishHookRef,
    flipflopRef,
    toothbrushRef,
    hotdogRef,
    rubberDuckyRef,
    level2ObstacleImagesRef,
    level2PickupImagesRef,
    level3ObstacleImagesRef,
    level3MushroomImagesRef,
    level3TrippyImagesRef,
    currentLevelRef,
    timedTextEventsRef,
    colorEventsRef,
    level2TimedEventsRef,
    level3TimedEventsRef,
    caveRef,
    speedMultiplier,
    setScore,
    setHealth,
    setLevelEnded,
    lastCollisionTimeRef,
    lastProximityScoreTimeRef,
    pickupSoundRef,
    hitSoundRef
  ));
};

================
File: src/components/Game/ParticleEffects.ts
================
import { Particle, Player } from '../../types';
import { getParticleColorFromStreak } from '../../utils/colorUtils';

/**
 * Draw a heart shape particle
 */
export const drawHeart = (ctx: CanvasRenderingContext2D, x: number, y: number, size: number, color: string, opacity: number) => {
  ctx.save();
  ctx.translate(x, y);
  ctx.beginPath();
  const topCurveHeight = size * 0.3;
  ctx.moveTo(0, topCurveHeight);
  ctx.bezierCurveTo(0, 0, -size / 2, 0, -size / 2, topCurveHeight);
  ctx.bezierCurveTo(-size / 2, size / 2, 0, size, 0, size);
  ctx.bezierCurveTo(0, size, size / 2, size / 2, size / 2, topCurveHeight);
  ctx.bezierCurveTo(size / 2, 0, 0, 0, 0, topCurveHeight);
  ctx.closePath();
  
  let r = parseInt(color.slice(1), 16) >> 16;
  let g = (parseInt(color.slice(1), 16) >> 8) & 255;
  let b = parseInt(color.slice(1), 16) & 255;
  ctx.fillStyle = `rgba(${r},${g},${b},${opacity})`;
  ctx.fill();
  ctx.restore();
};

/**
 * Create particles at a specific position
 */
export const createParticles = (particles: Particle[], x: number, y: number, color: string, count: number, shape: 'circle' | 'heart' = 'circle') => {
  for (let i = 0; i < count; i++) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      life: 1.0,
      color,
      size: 3 + Math.random() * 2,
      opacity: 0.7,
      shape,
    });
  }
};

/**
 * Create swimming particles behind the fish based on streak
 */
export const createSwimParticles = (particles: Particle[], player: Player, streak: number) => {
  const fishCenterX = player.x + player.width;
  const fishCenterY = player.y + player.height / 2;
  const tailX = fishCenterX - player.width;
  const particleCount = 1 + Math.floor(streak / 10);
  
  for (let i = 0; i < particleCount; i++) {
    particles.push({
      x: tailX + (Math.random() - 0.5) * 10,
      y: fishCenterY + (Math.random() - 0.5) * 10,
      vx: -2 - Math.random() * 2 - (streak * 0.1),
      vy: (Math.random() - 0.5) * (0.5 + streak * 0.05),
      life: 1.0,
      color: getParticleColorFromStreak(streak),
      size: 4 + Math.random() * 3 + (streak * 0.1),
      opacity: 0.8,
      shape: 'circle',
    });
  }
};

/**
 * Create particles for portrait mode animation
 */
export const createPortraitParticles = (particles: Particle[], x: number, y: number) => {
  for (let i = 0; i < 2; i++) {
    particles.push({
      x,
      y: y + (Math.random() - 0.5) * 10,
      vx: -2 - Math.random() * 2,
      vy: (Math.random() - 0.5) * 0.5,
      life: 1.0,
      color: '#FFD700',
      size: 4 + Math.random() * 3,
      opacity: 0.8,
      shape: 'circle'
    });
  }
};

/**
 * Update and draw particles
 */
export const updateAndDrawParticles = (ctx: CanvasRenderingContext2D, particles: Particle[], factor: number) => {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    
    // Update position
    p.x += p.vx * factor;
    p.y += p.vy * factor;
    
    // Update life and opacity
    p.life -= 0.02 * factor;
    p.opacity *= 0.97;
    
    // Remove dead particles
    if (p.life <= 0) { 
      particles.splice(i, 1); 
      continue; 
    }
    
    // Draw based on shape
    if (p.shape === 'heart') {
      drawHeart(ctx, p.x, p.y, p.size * p.life * 5, p.color, p.opacity);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      const opacityHex = Math.floor(p.opacity * 255).toString(16).padStart(2, '0');
      ctx.fillStyle = `${p.color}${opacityHex}`;
      ctx.fill();
    }
  }
};

================
File: src/components/Game/Player.ts
================
import { Player } from '../../types';

/**
 * Draw the player character (fish)
 */
export const drawPlayer = (
  ctx: CanvasRenderingContext2D, 
  player: Player, 
  fishImage: HTMLImageElement | null
) => {
  if (!fishImage || !fishImage.complete) return;
  
  // Calculate dimensions preserving aspect ratio
  const aspect = fishImage.naturalWidth / fishImage.naturalHeight;
  const drawWidth = player.width * 1.25;
  const drawHeight = drawWidth / aspect;
  
  ctx.save();
  
  // Position at center of player for rotation
  const centerX = player.x + player.width / 2;
  const centerY = player.y + player.height / 2;
  ctx.translate(centerX, centerY);
  
  // Apply rotation for swimming and spinning effects
  ctx.rotate(player.rotation + player.spinRotation);
  
  // Draw fish image
  ctx.drawImage(fishImage, -drawWidth / 2 + 20, -drawHeight / 2, drawWidth, drawHeight);
  
  // Add visual effect when hit
  if (player.hitTime) {
    const elapsed = Date.now() - player.hitTime;
    if (elapsed < 3000) {
      const overlayAlpha = 1 - (elapsed / 3000);
      const tintColor = player.hitType === 'fishhook' ? '255,0,0' : '0,0,0';
      
      // Create off-screen canvas for tinting effect
      const offscreen = document.createElement('canvas');
      offscreen.width = drawWidth;
      offscreen.height = drawHeight;
      const offCtx = offscreen.getContext('2d');
      
      if (offCtx) {
        // Draw fish to offscreen canvas
        offCtx.drawImage(fishImage, 0, 0, drawWidth, drawHeight);
        
        // Apply tint as overlay
        offCtx.globalCompositeOperation = 'source-atop';
        offCtx.fillStyle = `rgba(${tintColor},${overlayAlpha})`;
        offCtx.fillRect(0, 0, drawWidth, drawHeight);
        
        // Draw the tinted image back to main canvas
        ctx.drawImage(offscreen, -drawWidth / 2 + 20, -drawHeight / 2);
      }
    } else {
      // Reset hit state after effect duration
      player.hitTime = undefined;
      player.hitType = undefined;
    }
  }
  
  ctx.restore();
};

/**
 * Update player position based on input
 */
export const updatePlayerPosition = (
  player: Player,
  targetY: number,
  factor: number,
  isInputActive: boolean
) => {
  if (isInputActive) {
    // Calculate target position based on input
    const targetPlayerY = targetY - (player.height / 2);
    const currentY = player.y;
    const dy = targetPlayerY - currentY;
    
    // Apply smoothing to movement
    player.vy = player.vy * 0.9 + dy * 0.1 * factor;
    player.y += player.vy * 0.1 * factor;
    
    // Reduce rotation interpolation for smoother movement
    const targetRotation = Math.atan2(player.vy * 0.1 * factor, 2) * 0.25;
    player.rotation = targetRotation;
  } else {
    // Gradually slow down when no input
    player.vy *= 0.95;
    player.rotation *= 0.95;
  }
  
  // Handle spin rotation (from collisions or other events)
  if (player.spinRotation !== 0) {
    player.spinRotation *= 0.97;
    if (Math.abs(player.spinRotation) < 0.01) {
      player.spinRotation = 0;
    }
  }
  
  // Reset tiny rotations to zero
  if (Math.abs(player.rotation) < 0.01) {
    player.rotation = 0;
  }
};

/**
 * Draw player for portrait mode preview
 */
export const drawPlayerPortrait = (
  ctx: CanvasRenderingContext2D,
  fishImage: HTMLImageElement | null,
  position: { x: number, y: number, rotation: number }
) => {
  if (!fishImage || !fishImage.complete || !ctx.canvas) return;
  
  const time = Date.now() / 1000;
  const canvas = ctx.canvas;
  
  // Update fish position with gentle bobbing motion
  position.x = canvas.width * 0.5;
  position.y = canvas.height * 0.25 + Math.sin(time * 2) * 20;
  position.rotation = Math.sin(time * 2) * 0.1;
  
  // Draw the fish
  ctx.save();
  ctx.translate(position.x, position.y);
  ctx.rotate(position.rotation);
  
  const fishWidth = 100;
  const fishHeight = (fishWidth / fishImage.width) * fishImage.height;
  ctx.drawImage(fishImage, -fishWidth / 2, -fishHeight / 2, fishWidth, fishHeight);
  
  ctx.restore();
  
  return { x: position.x - fishWidth / 2, y: position.y };
};

================
File: src/components/GameUI/AboutModal.tsx
================
import React from 'react';

interface AboutModalProps {
  showAboutModal: boolean;
  setShowAboutModal: (show: boolean) => void;
}

const AboutModal: React.FC<AboutModalProps> = ({ showAboutModal, setShowAboutModal }) => {
  if (!showAboutModal) return null;
  
  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.5)',
        zIndex: 1000,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
      // Stop touch events from bubbling to underlying game elements
      onTouchStart={(e) => e.stopPropagation()}
      onTouchMove={(e) => e.stopPropagation()}
      onTouchEnd={(e) => e.stopPropagation()}
    >
      <div
        style={{
          width: '80%',
          maxWidth: '500px',
          height: '80vh', // explicit height for scrolling
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          borderRadius: '1rem',
          boxShadow: '0 0 20px rgba(0,0,0,0.5)',
          padding: '2rem',
          color: 'white',
          textAlign: 'center',
          overflowY: 'auto',
          WebkitOverflowScrolling: 'touch',
          touchAction: 'auto'
        }}
        onTouchStart={(e) => e.stopPropagation()}
        onTouchMove={(e) => e.stopPropagation()}
        onTouchEnd={(e) => e.stopPropagation()}
      >
        <h1 style={{ fontSize: '2rem', marginBottom: '1.5rem', color: '#FDF200' }}>
          CVCHE - MEET THE TRAILBLAZERS OF RURAL CANADIAN TECHNO
        </h1>
        <p style={{ fontSize: '1.2rem', marginBottom: '1.5rem', lineHeight: '1.6' }}>
          We are very excited to begin to share with you the vast catalog of our upcoming LP, 'Get Fluffy'.
        </p>
        <p style={{ fontSize: '1.2rem', marginBottom: '1.5rem', lineHeight: '1.6' }}>
          Over the next few months we'll be releasing more and more songs to please your ears until the album comes out in full. So put on ur socks, find a waxed floor to dance on and enjoy! Rural Canadian Techno 4evur!
        </p>
        <p style={{ fontSize: '1.2rem', marginBottom: '1.5rem', lineHeight: '1.6' }}>
          We live in a Tiny Sovereign Nation, on an island between two forks of a river.
        </p>
        <div style={{ marginBottom: '2rem' }}>
          <button
            onClick={() =>
              window.open(
                'https://urnowhere.notion.site/19f92b5e7a6e80389c83fbc8d454c548',
                '_blank'
              )
            }
            style={{
              padding: '1rem 2rem',
              fontSize: '1.1rem',
              backgroundColor: '#FDF200',
              border: 'none',
              borderRadius: '0.5rem',
              cursor: 'pointer',
              color: 'black',
              fontFamily: 'Orbitron, sans-serif',
              marginBottom: '1rem'
            }}
          >
            Sign Up for Updates
          </button>
        </div>
        <button
          onClick={() => setShowAboutModal(false)}
          style={{
            padding: '0.5rem 1rem',
            fontSize: '1rem',
            backgroundColor: 'transparent',
            border: '2px solid white',
            borderRadius: '0.5rem',
            cursor: 'pointer',
            color: 'white',
            fontFamily: 'Orbitron, sans-serif'
          }}
        >
          Close
        </button>
      </div>
    </div>
  );
};

export default AboutModal;

================
File: src/components/GameUI/GameControls.tsx
================
import React from 'react';
import ProgressBar from './ProgressBar';

interface GameControlsProps {
  gameStarted: boolean;
  isPaused: boolean;
  togglePause: () => void;
  currentLevel: { highScore?: number };
  score: number;
  audioProgress: number;
  currentTime: number;
  duration: number;
}

const GameControls: React.FC<GameControlsProps> = ({
  gameStarted,
  isPaused,
  togglePause,
  currentLevel,
  score,
  audioProgress,
  currentTime,
  duration
}) => {
  return (
    <div style={{
      position: 'fixed',
      left: 0,
      right: 0,
      height: '50px',
      display: 'flex',
      alignItems: 'center',
      padding: '0 20px',
      zIndex: 10,
      color: '#fff',
      justifyContent: 'space-between',
      fontFamily: 'Orbitron, sans-serif'
    }}>
      <div style={{ display: 'flex', alignItems: 'center', gap: '20px', flex: 1 }}>
        {gameStarted && (
          <button 
            onClick={togglePause} 
            style={{ 
              background: '#0066FF', 
              border: 'none', 
              color: '#fff', 
              padding: '5px 15px', 
              cursor: 'pointer', 
              borderRadius: '4px' 
            }}
          >
            {isPaused ? 'Play' : 'Pause'}
          </button>
        )}
        <div style={{ whiteSpace: 'nowrap' }}>High Score: {currentLevel.highScore || 0}</div>
        <div style={{ whiteSpace: 'nowrap' }}>Score: {score}</div>
        {gameStarted && (
          <a 
            href="https://open.spotify.com/album/3nDX07NcGIyEeFtZIep9NB" 
            target="_blank" 
            rel="noopener noreferrer" 
            style={{ 
              background: '#1DB954', 
              padding: '5px 10px', 
              borderRadius: '4px', 
              color: '#fff', 
              textDecoration: 'none' 
            }}
          >
            Spotify
          </a>
        )}
      </div>
      
      {gameStarted && (
        <ProgressBar 
          audioProgress={audioProgress} 
          currentTime={currentTime} 
          duration={duration} 
        />
      )}
    </div>
  );
};

export default GameControls;

================
File: src/components/GameUI/HealthBar.tsx
================
import React from 'react';
import { getHealthBarColor } from '../../utils/colorUtils';

interface HealthBarProps {
  health: number;
}

const HealthBar: React.FC<HealthBarProps> = ({ health }) => {
  return (
    <div style={{
      position: 'absolute',
      top: '60px',
      left: '20px',
      display: 'flex',
      alignItems: 'center',
      gap: '10px',
      zIndex: 10
    }}>
      <div style={{
        width: '200px',
        height: '20px',
        backgroundColor: 'rgba(0,0,0,0.5)',
        borderRadius: '10px',
        overflow: 'hidden'
      }}>
        <div style={{
          width: `${health}%`,
          height: '100%',
          backgroundColor: getHealthBarColor(health),
          transition: 'width 0.3s ease-out'
        }} />
      </div>
      <span style={{
        color: 'white',
        fontSize: '16px',
        fontFamily: 'Orbitron, sans-serif',
        textShadow: '2px 2px 4px rgba(0,0,0,0.5)'
      }}>
        Health
      </span>
    </div>
  );
};

export default HealthBar;

================
File: src/components/GameUI/LevelCompleteScreen.tsx
================
import React from 'react';
import { Level, GameState } from '../../types';

interface LevelCompleteScreenProps {
  levelEnded: boolean;
  health: number;
  score: number;
  gameState: GameState;
  levels: Level[];
  currentLevel: Level;
  selectLevel: (level: Level) => void;
  setLevelEnded: (ended: boolean) => void;
  setGameStarted: (started: boolean) => void;
  restartGameLoop: () => void; // Add new prop for restarting the game loop
}

const LevelCompleteScreen: React.FC<LevelCompleteScreenProps> = ({
  levelEnded,
  health,
  score,
  gameState,
  levels,
  currentLevel,
  selectLevel,
  setLevelEnded,
  setGameStarted,
  restartGameLoop // Destructure the new prop
}) => {
  if (!levelEnded) return null;
  
  const isGameOver = health <= 0;
  const nextLevel = levels.find(l => l.id === currentLevel.id + 1);
  
  const restartGame = () => {
    window.location.reload();
  };
  
  const startNextLevel = () => {
    if (nextLevel && nextLevel.unlocked) {
      selectLevel(nextLevel);
      setLevelEnded(false);
      setGameStarted(true);
      // Restart the game loop to ensure rendering continues
      restartGameLoop();
    }
  };
  
  return (
    <div 
      style={{ 
        position: 'absolute', 
        top: 0, 
        left: 0, 
        right: 0, 
        bottom: 0, 
        backgroundColor: 'rgba(0, 0, 0, 0.8)', 
        color: '#fff', 
        display: 'flex', 
        flexDirection: 'column', 
        alignItems: 'center', 
        justifyContent: 'center', 
        zIndex: 30, 
        fontFamily: 'Orbitron, sans-serif' 
      }}
    >
      <h1 style={{ marginTop: 0, fontSize: '48px', marginBottom: '20px' }}>
        {isGameOver ? 'Game Over!' : 'Level Complete!'}
      </h1>
      
      <div style={{ fontSize: '24px', marginBottom: '10px' }}>
        Final Score: {score}
      </div>
      
      <div style={{ fontSize: '24px', marginBottom: '10px' }}>
        Highest Streak: {gameState.highestStreak}
      </div>
      
      <div style={{ fontSize: '24px', marginBottom: '20px' }}>
        Trash Collected: {gameState.trashStats.collected} / {gameState.trashStats.totalSpawned} (
        {gameState.trashStats.totalSpawned > 0
          ? Math.round((gameState.trashStats.collected / gameState.trashStats.totalSpawned) * 100)
          : 0}%
        )
      </div>
      
      <div style={{ marginBottom: '20px' }}>
        <button
          onClick={() => window.open('https://urnowhere.notion.site/19f92b5e7a6e80389c83fbc8d454c548', '_blank')}
          style={{ 
            padding: '10px 20px', 
            fontSize: '16px', 
            cursor: 'pointer', 
            backgroundColor: '#0066FF', 
            border: 'none', 
            borderRadius: '4px', 
            color: '#fff' 
          }}
        >
          Sign Up for Updates
        </button>
      </div>
      
      <div style={{ display: 'flex', gap: '20px' }}>
        <button 
          onClick={restartGame} 
          style={{ 
            padding: '15px 30px', 
            fontSize: '20px', 
            cursor: 'pointer', 
            backgroundColor: '#444', 
            border: 'none', 
            borderRadius: '8px', 
            color: '#fff' 
          }}
        >
          Play Again
        </button>
        
        {nextLevel && nextLevel.unlocked && (
          <button 
            onClick={startNextLevel} 
            style={{ 
              padding: '15px 30px', 
              fontSize: '20px', 
              cursor: 'pointer', 
              backgroundColor: '#0066FF', 
              border: 'none', 
              borderRadius: '8px', 
              color: '#fff' 
            }}
          >
            Next Level
          </button>
        )}
      </div>
    </div>
  );
};

export default LevelCompleteScreen;

================
File: src/components/GameUI/LevelSelector.tsx
================
import React from 'react';
import { Level } from '../../types';

interface LevelSelectorProps {
  levels: Level[];
  currentLevel: Level;
  selectLevel: (level: Level) => void;
}

const LevelSelector: React.FC<LevelSelectorProps> = ({ levels, currentLevel, selectLevel }) => {
  return (
    <div style={{
      display: 'flex',
      flexWrap: 'wrap',
      gap: '1rem',
      justifyContent: 'center',
      padding: '1rem',
      maxWidth: '800px',
      margin: '0 auto'
    }}>
      {levels.map(level => (
        <button
          key={level.id}
          onClick={() => level.unlocked && selectLevel(level)}
          disabled={!level.unlocked}
          style={{
            padding: '1rem',
            minWidth: '12rem',
            background: level.id === currentLevel.id ? '#0066FF' : 'rgba(0, 0, 0, 0.3)',
            color: 'white',
            border: level.id === currentLevel.id ? '2px solid white' : '2px solid transparent',
            borderRadius: '0.5rem',
            fontSize: '1rem',
            fontFamily: 'Orbitron, sans-serif',
            cursor: level.unlocked ? 'pointer' : 'not-allowed',
            opacity: level.unlocked ? 1 : 0.5,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '0.5rem',
            transition: 'transform 0.2s, opacity 0.2s',
            transform: level.id === currentLevel.id ? 'scale(1.05)' : 'scale(1)'
          }}
        >
          <div style={{ fontWeight: 'bold' }}>Level {level.id}</div>
          <div>{level.title}</div>
          {level.highScore !== undefined && level.highScore > 0 && (
            <div style={{ fontSize: '0.8rem', opacity: 0.8 }}>
              High Score: {level.highScore}
            </div>
          )}
          {!level.unlocked && <div>🔒</div>}
        </button>
      ))}
    </div>
  );
};

export default LevelSelector;

================
File: src/components/GameUI/PauseScreen.tsx
================
import React from 'react';
import { Level } from '../../types';

interface PauseScreenProps {
  isPaused: boolean;
  levelEnded: boolean;
  isLandscape: boolean;
  currentLevel: Level;
  pendingLevel: Level | null;
  levels: Level[];
  togglePause: () => void;
  setPendingLevel: (level: Level | null) => void;
  selectLevel: (level: Level) => void;
  restartGameLoop: () => void; // <-- Added prop
}

const PauseScreen: React.FC<PauseScreenProps> = ({
  isPaused,
  levelEnded,
  isLandscape,
  currentLevel,
  pendingLevel,
  levels,
  togglePause,
  setPendingLevel,
  selectLevel,
  restartGameLoop // <-- Destructure new prop
}) => {
  if (!isPaused || levelEnded || !isLandscape) return null;
  
  return (
    <div style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0,0,0,0.7)',
      zIndex: 35,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '1rem',
      fontFamily: 'Orbitron, sans-serif',
      color: '#fff'
    }}>
      <div style={{ fontSize: '48px' }}>Paused</div>
      <div style={{ fontSize: '24px' }}>High Score: {currentLevel.highScore || 0}</div>
      
      <div style={{ display: 'flex', gap: '20px' }}>
        {pendingLevel && pendingLevel.id !== currentLevel.id ? (
          <button
            onClick={() => {
              selectLevel(pendingLevel);
              setPendingLevel(null);
              togglePause();
              restartGameLoop(); // <-- Restart game loop after level switch
            }}
            style={{
              padding: '10px 20px',
              fontSize: '20px',
              cursor: 'pointer',
              backgroundColor: '#0066FF',
              border: 'none',
              borderRadius: '8px',
              color: '#fff',
            }}
          >
            Play
          </button>
        ) : (
          <button
            onClick={togglePause}
            style={{
              padding: '10px 20px',
              fontSize: '20px',
              cursor: 'pointer',
              backgroundColor: '#0066FF',
              border: 'none',
              borderRadius: '8px',
              color: '#fff',
            }}
          >
            Resume
          </button>
        )}
      </div>
      
      <div style={{
        display: 'flex',
        flexDirection: 'row',
        gap: '1rem',
        overflowX: 'auto',
        padding: '0 10px',
        width: '100%',
        justifyContent: 'space-evenly',
      }}>
        {levels.map((level) => {
          const isSelected = pendingLevel ? pendingLevel.id === level.id : currentLevel.id === level.id;
          return (
            <button
              key={level.id}
              onClick={() => setPendingLevel(level)}
              disabled={!level.unlocked}
              style={{
                margin: '10px',
                padding: '10px 20px',
                minWidth: '180px',
                fontSize: '16px',
                borderRadius: '8px',
                border: isSelected ? '2px solid #fff' : 'none',
                cursor: level.unlocked ? 'pointer' : 'not-allowed',
                backgroundColor: isSelected ? '#0066FF' : 'rgba(0, 0, 0, 0.5)',
                color: '#fff',
                opacity: level.unlocked ? 1 : 0.5,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                transition: 'transform 0.2s, opacity 0.2s',
                transform: isSelected ? 'scale(1.1)' : 'scale(1)',
              }}
            >
              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                <span style={{ fontSize: '14px' }}>LVL {level.id}</span>
                <span style={{ fontSize: '14px' }}>{level.title}</span>
              </div>
              {!level.unlocked && (
                <span style={{ fontSize: '12px' }}>🔒</span>
              )}
            </button>
          );
        })}
      </div>
    </div>
  );
};

export default PauseScreen;

================
File: src/components/GameUI/PortraitScreen.tsx
================
import React, { useRef, useEffect } from 'react';

interface PortraitScreenProps {
  isPortrait: boolean;
  gameStarted: boolean;
  isPaused: boolean;
  setShowAboutModal: (show: boolean) => void;
  animatePortrait: (ctx: CanvasRenderingContext2D) => void;
}

const PortraitScreen: React.FC<PortraitScreenProps> = ({ 
  isPortrait, 
  gameStarted, 
  isPaused, 
  setShowAboutModal,
  animatePortrait 
}) => {
  const portraitCanvasRef = useRef<HTMLCanvasElement | null>(null);
  
  // Start portrait animation when in portrait mode
  useEffect(() => {
    if (portraitCanvasRef.current && isPortrait) {
      const ctx = portraitCanvasRef.current.getContext('2d');
      if (ctx) {
        portraitCanvasRef.current.width = window.innerWidth;
        portraitCanvasRef.current.height = window.innerHeight;
        
        let animationFrameId: number;
        const animate = () => {
          animatePortrait(ctx);
          animationFrameId = requestAnimationFrame(animate);
        };
        
        animate();
        
        // Handle resize to keep canvas dimensions updated
        const handleResize = () => {
          if (portraitCanvasRef.current) {
            portraitCanvasRef.current.width = window.innerWidth;
            portraitCanvasRef.current.height = window.innerHeight;
          }
        };
        
        window.addEventListener('resize', handleResize);
        
        return () => {
          cancelAnimationFrame(animationFrameId);
          window.removeEventListener('resize', handleResize);
        };
      }
    }
  }, [isPortrait, animatePortrait]);
  
  if (!isPortrait) return null;
  
  const showWhenPaused = isPaused && gameStarted;
  
  return (
    <div 
      style={{ 
        position: 'absolute', 
        top: 0, 
        left: 0, 
        height: '100%', 
        width: '100%', 
        background: 'black', 
        display: 'flex', 
        flexDirection: 'column', 
        justifyContent: 'center', 
        alignItems: 'center', 
        zIndex: 100 
      }}
    >
      <canvas
        ref={portraitCanvasRef}
        style={{ 
          position: 'absolute', 
          top: 0, 
          left: 0, 
          width: '100%', 
          height: '100%' 
        }}
      />
      
      <h1 style={{ 
        fontSize: '3rem', 
        margin: '15vh 0 0 0', 
        fontWeight: 'bold', 
        color: '#FDEE03', 
        zIndex: 101 
      }}>
        CVCHE
      </h1>
      
      <div style={{ 
        fontSize: '1.2rem', 
        color: '#FFFFFF', 
        zIndex: 101, 
        padding: '20px', 
        textAlign: 'center',
        marginTop: '20vh',
        backgroundColor: 'rgba(0, 0, 0, 0.6)',
        borderRadius: '10px'
      }}>
        Please rotate your device to <strong style={{ color: '#ED1D24' }}>landscape</strong> to {showWhenPaused ? 'resume' : 'play'} this game.
      </div>
      
      <nav style={{ 
        marginTop: '2rem', 
        display: 'flex', 
        flexDirection: 'column', 
        gap: '2rem', 
        fontSize: '1.2rem', 
        zIndex: 101 
      }}>
        <div style={{ display: 'flex', gap: '2rem', justifyContent: 'center' }}>
          <a 
            href="https://vyd.co/WelcomeToCvche" 
            target="_blank" 
            rel="noopener noreferrer" 
            style={{ color: '#FDEE03' }}
          >
            Music
          </a>
          <a 
            href="https://www.instagram.com/cvche" 
            style={{ color: '#FDEE03' }}
          >
            Socials
          </a>
          <button 
            onClick={() => setShowAboutModal(true)} 
            style={{ 
              background: 'none', 
              border: 'none', 
              color: '#FDEE03', 
              fontSize: 'inherit', 
              cursor: 'pointer', 
              padding: '0' 
            }}
          >
            About
          </button>
        </div>
      </nav>
    </div>
  );
};

export default PortraitScreen;

================
File: src/components/GameUI/ProgressBar.tsx
================
import React from 'react';
import { formatTime } from '../../utils/colorUtils';

interface ProgressBarProps {
  audioProgress: number;
  currentTime: number;
  duration: number;
}

const ProgressBar: React.FC<ProgressBarProps> = ({ audioProgress, currentTime, duration }) => {
  return (
    <div style={{ 
      display: 'flex', 
      alignItems: 'center', 
      gap: '10px', 
      flex: 1, 
      width: '100%', 
      paddingLeft: '20px' 
    }}>
      <div style={{ 
        flex: 1, 
        height: '4px', 
        background: 'rgba(255, 255, 255, 0.2)', 
        borderRadius: '2px', 
        overflow: 'hidden' 
      }}>
        <div style={{ 
          width: `${audioProgress}%`, 
          height: '100%', 
          background: '#0066FF', 
          transition: 'width 0.1s linear' 
        }} />
      </div>
      <div style={{ fontSize: '14px' }}>
        {formatTime(currentTime)} / {formatTime(duration)}
      </div>
    </div>
  );
};

export default ProgressBar;

================
File: src/components/GameUI/StreakDisplay.tsx
================
import React from 'react';
import { getParticleColorFromStreak } from '../../utils/colorUtils';

interface StreakDisplayProps {
  streak: number;
  multiplier: number;
  scale: number;
}

const StreakDisplay: React.FC<StreakDisplayProps> = ({ streak, multiplier, scale }) => {
  return (
    <div style={{ 
      position: 'fixed', 
      top: '60px', 
      right: '20px', 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'flex-end', 
      gap: '5px', 
      zIndex: 10, 
      fontFamily: 'Orbitron, sans-serif'
    }}>
      <div style={{ 
        background: 'rgba(0, 0, 0, 0.5)', 
        padding: '10px 20px', 
        borderRadius: '8px', 
        transform: `scale(${scale})`, 
        transition: 'transform 0.1s ease-out', 
        fontFamily: 'Orbitron, sans-serif' 
      }}>
        <div style={{ 
          color: getParticleColorFromStreak(streak), 
          fontSize: '24px', 
          fontWeight: 'bold', 
          textShadow: '0 0 10px rgba(255,255,255,0.3)', 
          transition: 'color 0.3s', 
          fontFamily: 'Orbitron, sans-serif' 
        }}>
          {streak} STREAK
        </div>
        <div style={{ 
          color: '#fff', 
          fontSize: '18px', 
          opacity: 0.8, 
          fontFamily: 'Orbitron, sans-serif' 
        }}>
          {multiplier}x MULTIPLIER
        </div>
      </div>
    </div>
  );
};

export default StreakDisplay;

================
File: src/components/GameUI/WelcomeScreen.tsx
================
import React, { useRef, useEffect } from 'react';

interface WelcomeScreenProps {
  gameStarted: boolean;
  isLandscape: boolean;
  floraLoaded: boolean;
  startGame: () => void;
  setShowAboutModal: (show: boolean) => void;
}

const WelcomeScreen: React.FC<WelcomeScreenProps> = ({
  gameStarted,
  isLandscape,
  floraLoaded,
  startGame,
  setShowAboutModal
}) => {
  const landscapePreviewCanvasRef = useRef<HTMLCanvasElement | null>(null);
  
// In src/components/GameUI/WelcomeScreen.tsx, update the animation function
// to match the in-game fish position and particles exactly

useEffect(() => {
  if (gameStarted || !isLandscape || !landscapePreviewCanvasRef.current) return;
  
  const canvas = landscapePreviewCanvasRef.current;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  
  const updateCanvasSize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  };
  
  updateCanvasSize();
  window.addEventListener('resize', updateCanvasSize);
  
  // Import the same fish image used in the game
  const fishImage = new Image();
  fishImage.src = '/sprites/cvcheFish.webp';
  
  // Recreate the same particles as in-game
  const particles: {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
    opacity: number;
  }[] = [];
  
  // Create particles that match the game trail
  const createSwimParticles = (x: number, y: number) => {
    // Match the game's createSwimParticles function
    const fishCenterX = x + 50; // x position + player.width
    const fishCenterY = y + 15; // y position + player.height / 2
    const tailX = fishCenterX - 50; // fishCenterX - player.width
    
    for (let i = 0; i < 1; i++) {
      particles.push({
        x: tailX + (Math.random() - 0.5) * 10,
        y: fishCenterY + (Math.random() - 0.5) * 10,
        vx: -2 - Math.random() * 2,
        vy: (Math.random() - 0.5) * 0.5,
        life: 1.0,
        color: '#FFD700', // Starting color, matching the initial streak color
        size: 4 + Math.random() * 3,
        opacity: 0.8
      });
    }
  };
  
  // Update and draw particles just like in the game
  const updateAndDrawParticles = () => {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      
      // Update position
      p.x += p.vx;
      p.y += p.vy;
      
      // Update life and opacity
      p.life -= 0.02;
      p.opacity *= 0.97;
      
      // Remove dead particles
      if (p.life <= 0) { 
        particles.splice(i, 1); 
        continue; 
      }
      
      // Draw particle
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      const opacityHex = Math.floor(p.opacity * 255).toString(16).padStart(2, '0');
      ctx.fillStyle = `${p.color}${opacityHex}`;
      ctx.fill();
    }
  };
  
  let animFrameId: number;
  const animate = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Use actual level 1 yellow background
    ctx.fillStyle = "#FDF200";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add subtle wave patterns
    ctx.save();
    ctx.strokeStyle = 'rgba(253,242,0,0.4)';
    ctx.lineWidth = 2;
    const time = Date.now() / 1000;
    
    // Draw wave pattern similar to in-game
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      const offset = i * 50;
      const timeOffset = time + (i * 0.5);
      
      for (let x = 0; x < canvas.width; x += 5) {
        const frequency = 4 + Math.sin(timeOffset) * 2;
        const y = canvas.height - 100 + Math.sin((x / canvas.width * frequency * Math.PI) + timeOffset + offset) * 30;
        
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.restore();
    
    // Draw fish animation using the same style as in-game
    if (fishImage.complete) {
      // Position fish on the left side just like in-game (default x position is 100)
      const x = 100;
      const y = canvas.height / 2 + Math.sin(time * 2) * 20;
      
      // Create swim particles at a rate matching the game
      if (Math.random() < 0.3) {
        createSwimParticles(x, y);
      }
      
      // Update and draw particles
      updateAndDrawParticles();
      
      // Use the same fish drawing approach as in-game
      ctx.save();
      
      // Calculate dimensions preserving aspect ratio like in the game
      const fishWidth = 50 * 1.25; // Same as in drawPlayer function
      const aspect = fishImage.naturalWidth / fishImage.naturalHeight;
      const fishHeight = fishWidth / aspect;
      
      // Position at center of fish for rotation
      const centerX = x + 25; // x + width/2
      const centerY = y + 15; // y + height/2
      ctx.translate(centerX, centerY);
      
      // Apply gentle swimming rotation
      const rotation = Math.sin(time * 2) * 0.1;
      ctx.rotate(rotation);
      
      // Draw fish image with same offset as in the game
      ctx.drawImage(fishImage, -fishWidth / 2 + 20, -fishHeight / 2, fishWidth, fishHeight);
      
      ctx.restore();
    }
    
    animFrameId = requestAnimationFrame(animate);
  };
  
  animate();
  
  return () => {
    cancelAnimationFrame(animFrameId);
    window.removeEventListener('resize', updateCanvasSize);
  };
}, [gameStarted, isLandscape]);
  
  if (gameStarted || !isLandscape) return null;
  
  return (
    <>
      <canvas
        ref={landscapePreviewCanvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          zIndex: 2,
          display: 'block'
        }}
      />
      <div
        style={{
          position: 'absolute',
          top: '50dvh',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          zIndex: 20,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '2rem',
          textAlign: 'center',
          fontFamily: 'Orbitron, sans-serif',
        }}
      >
        <h1 style={{ fontSize: '3rem', margin: 0, fontWeight: 'bold', color: '#000' }}>CVCHE</h1>
        <nav
          style={{
            display: 'flex',
            gap: '2rem',
            fontSize: '1.2rem',
            color: '#000',
          }}
        >
          <a 
            href="https://vyd.co/WelcomeToCvche" 
            target="_blank" 
            rel="noopener noreferrer" 
            style={{ textDecoration: 'underline', color: '#000' }}
          >
            Music
          </a>
          <a 
            href="https://www.instagram.com/cvche" 
            style={{ textDecoration: 'underline', color: '#000' }}
          >
            Socials
          </a>
          <span 
            onClick={() => setShowAboutModal(true)} 
            style={{ textDecoration: 'underline', cursor: 'pointer', color: '#000' }}
          >
            About
          </span>
        </nav>
        {!floraLoaded ? (
          <div style={{ padding: '20px 60px', fontSize: '24px', color: '#000' }}>
            Loading...
          </div>
        ) : (
          <button
            onClick={startGame}
            style={{
              border: 'none',
              color: '#fff',
              padding: '20px 60px',
              fontSize: '24px',
              borderRadius: '8px',
              cursor: 'pointer',
              boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
              transition: 'transform 0.2s',
              background: '#0066FF',
            }}
          >
            Play Music
          </button>
        )}
      </div>
    </>
  );
};

export default WelcomeScreen;

================
File: src/components/MusicReactiveOceanGame.tsx
================
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { useGameState } from '../hooks/useGameState';
import { useAudio } from '../hooks/useAudio';
import { useInputHandlers } from '../hooks/useInputHandler';
import { AssetLoader } from '../utils/assetLoader';
import { initializeFlora } from './Game/Flora';
import { gameLoop } from './Game/GameLoop';
import { drawPlayerPortrait } from './Game/Player';
import { createPortraitParticles, updateAndDrawParticles } from './Game/ParticleEffects';

// UI Components
import AboutModal from './GameUI/AboutModal';
import GameControls from './GameUI/GameControls';
import HealthBar from './GameUI/HealthBar';
import LevelCompleteScreen from './GameUI/LevelCompleteScreen';
import PauseScreen from './GameUI/PauseScreen';
import PortraitScreen from './GameUI/PortraitScreen';
import StreakDisplay from './GameUI/StreakDisplay';
import WelcomeScreen from './GameUI/WelcomeScreen';

import { GameProps } from '../types';

const MusicReactiveOceanGame: React.FC<GameProps> = ({ onGameStart }): React.ReactElement => {
  // Load game state from custom hook
  const gameState = useGameState();

  // Asset loading states
  const [floraLoaded, setFloraLoaded] = useState(false);
  const [level2AssetsLoaded, setLevel2AssetsLoaded] = useState(false);
  const [level3AssetsLoaded, setLevel3AssetsLoaded] = useState(false);

  // Canvas refs - using non-null assertion for canvasRef to fix type issues
  const canvasRef = useRef<HTMLCanvasElement>(null!);
  const starsCanvasRef = useRef<HTMLCanvasElement>(null);
  const portraitCanvasRef = useRef<HTMLCanvasElement>(null);

  // Asset loader
  const assetLoader = useRef<AssetLoader>(new AssetLoader());
  gameState.pickupSoundRef = useRef<HTMLAudioElement>(null!);
  gameState.hitSoundRef = useRef<HTMLAudioElement>(null!);

  // Asset refs
  const fishImageRef = useRef<HTMLImageElement>(null!);
  const waterBottleRef = useRef<HTMLImageElement>(null!);
  const plasticBagRef = useRef<HTMLImageElement>(null!);
  const oilSplatImageRef = useRef<HTMLImageElement>(null!);
  const fishHookRef = useRef<HTMLImageElement>(null!);
  const flipflopRef = useRef<HTMLImageElement>(null!);
  const toothbrushRef = useRef<HTMLImageElement>(null!);
  const hotdogRef = useRef<HTMLImageElement>(null!);
  const rubberDuckyRef = useRef<HTMLImageElement>(null!);

  // Set up audio hooks with a proper type for the audio element
  const {
    audioRef,
    getAverageAmplitude,
    detectBeat
  } = useAudio(
    gameState.gameStarted,
    gameState.isPaused,
    gameState.setAudioProgress,
    gameState.setCurrentTime,
    gameState.setDuration,
    gameState.setLevelEnded,
    gameState.gameLoopRef,
    gameState.animationFrameIdRef,
    gameState.analyserRef,
    gameState.dataArrayRef,
    gameState.lastBeatTimeRef,
    gameState.currentLevel.id // <-- pass the current level id here

  );

  // Create non-null audio ref for the game loop
  const audioRefNonNull = useRef<HTMLAudioElement>(null!);

  // Keep audioRefNonNull.current in sync with audioRef.current
  useEffect(() => {
    if (audioRef.current) {
      audioRefNonNull.current = audioRef.current;
    }
  }, [audioRef.current]);

  useEffect(() => {
    if (!gameState.gameStarted) return;
    // Stop current audio
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
    }
    // Set the new audio source based on the current level
    if (audioRef.current) {
      audioRef.current.src = gameState.currentLevel.songFile;
      audioRef.current.load(); // NEW: Ensure the new source is loaded
      // Reset audio-related state
      gameState.setAudioProgress(0);
      gameState.setCurrentTime(0);
      gameState.setDuration(0);
      // If not paused, start playing the new level's audio
      if (!gameState.isPaused) {
        console.log("Starting new audio, currentLevel:", gameState.currentLevel, audioRef.current.src);
        audioRef.current.play().catch(console.error);
      }
    }
  }, [gameState.currentLevel.id, gameState.gameStarted]);
  const { inputRef } = useInputHandlers(canvasRef);

  // Define the restartGameLoop function first so we can register it with useGameState
  const restartGameLoop = useCallback(() => {
    gameState.gameLoopRef.current = true;
    gameState.animationFrameIdRef.current = requestAnimationFrame(() =>
      gameLoop(
        canvasRef,
        gameState.gameStateRef,
        gameState.lastFrameTimeRef,
        gameState.gameLoopRef,
        gameState.animationFrameIdRef,
        audioRefNonNull,
        gameState.audioProgressRef,
        getAverageAmplitude,
        detectBeat,
        gameState.lastBeatTimeRef,
        inputRef,
        gameState.backgroundColorRef,
        gameState.waveColorRef,
        gameState.activeColorTransitionRef,
        gameState.bgPatternBubblesRef,
        gameState.levelTogglesRef,
        gameState.bubblesRef,
        gameState.amplitudeRef,
        gameState.activeTimedTextsRef,
        gameState.floraItemsRef,
        gameState.streakDisplayRef,
        fishImageRef,
        waterBottleRef,
        plasticBagRef,
        oilSplatImageRef,
        fishHookRef,
        flipflopRef,
        toothbrushRef,
        hotdogRef,
        rubberDuckyRef,
        gameState.level2ObstacleImagesRef,
        gameState.level2PickupImagesRef,
        gameState.level3ObstacleImagesRef,
        gameState.level3MushroomImagesRef,
        gameState.level3TrippyImagesRef,
        gameState.currentLevelRef,
        gameState.timedTextEventsRef,
        gameState.colorEventsRef,
        gameState.level2TimedEventsRef,
        gameState.level3TimedEventsRef,
        gameState.caveRef,
        gameState.speedMultiplier,
        gameState.setScore,
        gameState.setHealth,
        gameState.setLevelEnded,
        gameState.lastCollisionTimeRef,
        gameState.lastProximityScoreTimeRef,
        gameState.pickupSoundRef as React.RefObject<HTMLAudioElement>,
        gameState.hitSoundRef as React.RefObject<HTMLAudioElement>
      )
    );
  }, [
    canvasRef,
    gameState,
    audioRefNonNull,
    getAverageAmplitude,
    detectBeat,
    inputRef,
    gameState.setScore,
    gameState.setHealth,
    gameState.setLevelEnded
  ]);

  // Register the restartGameLoop function with useGameState
  useEffect(() => {
    if (gameState.setRestartGameLoopRef) {
      gameState.setRestartGameLoopRef(restartGameLoop);
    }
  }, [restartGameLoop, gameState.setRestartGameLoopRef]);

  // Load basic assets on component mount
  useEffect(() => {
    const loader = assetLoader.current;
    const loadAssets = async () => {
      await loader.loadBasicAssets();
      // Update refs with loaded assets
      if (loader.fishImage) {
        fishImageRef.current = loader.fishImage;
      }
      if (loader.waterBottleImage) {
        waterBottleRef.current = loader.waterBottleImage;
        window.waterBottleRef = waterBottleRef;
      }
      if (loader.plasticBagImage) {
        plasticBagRef.current = loader.plasticBagImage;
        window.plasticBagRef = plasticBagRef;
      }
      if (loader.oilSplatImage) {
        oilSplatImageRef.current = loader.oilSplatImage;
      }
      if (loader.fishHookImage) {
        fishHookRef.current = loader.fishHookImage;
      }
      if (loader.flipflopImage) {
        flipflopRef.current = loader.flipflopImage;
      }
      if (loader.toothbrushImage) {
        toothbrushRef.current = loader.toothbrushImage;
      }
      if (loader.hotdogImage) {
        hotdogRef.current = loader.hotdogImage;
      }
      if (loader.rubberDuckyImage) {
        rubberDuckyRef.current = loader.rubberDuckyImage;
      }
      gameState.pickupSoundRef.current = loader.pickupSound;
      gameState.hitSoundRef.current = loader.hitSound;
      // Load flora assets
      await loader.loadFloraAssets();
      // Initialize flora once loaded
      if (canvasRef.current) {
        gameState.floraItemsRef.current = initializeFlora(canvasRef.current, loader.floraImages);
      }
      setFloraLoaded(true);
    };
    loadAssets();
  }, []);

  // Load level 2 assets when needed
  useEffect(() => {
    if (gameState.currentLevel.id === 2 && !level2AssetsLoaded) {
      const loadLevel2 = async () => {
        await assetLoader.current.loadLevel2Assets();
        // Update level 2 asset refs
        gameState.level2ObstacleImagesRef.current = assetLoader.current.level2ObstacleImages;
        gameState.level2PickupImagesRef.current = assetLoader.current.level2PickupImages;
        setLevel2AssetsLoaded(true);
      };
      loadLevel2();
    }
  }, [gameState.currentLevel.id, level2AssetsLoaded]);

  // Load level 3 assets when needed
  useEffect(() => {
    if (gameState.currentLevel.id === 3 && !level3AssetsLoaded) {
      const loadLevel3 = async () => {
        await assetLoader.current.loadLevel3Assets();
        // Update level 3 asset refs
        gameState.level3ObstacleImagesRef.current = assetLoader.current.level3ObstacleImages;
        gameState.level3MushroomImagesRef.current = assetLoader.current.level3MushroomImages;
        gameState.level3TrippyImagesRef.current = assetLoader.current.level3TrippyImages;
        setLevel3AssetsLoaded(true);
        console.log('Level 3 assets loaded:', {
          obstacles: gameState.level3ObstacleImagesRef.current.length,
          mushrooms: gameState.level3MushroomImagesRef.current.length,
          trippyImages: gameState.level3TrippyImagesRef.current.length
        });
      };
      loadLevel3();
    }
  }, [gameState.currentLevel.id, level3AssetsLoaded]);

  // Reset canvas on resize
  useEffect(() => {
    const handleResize = () => {
      if (canvasRef.current) {
        canvasRef.current.width = window.innerWidth;
        canvasRef.current.height = window.innerHeight;
      }
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Portrait animation function
  const animatePortrait = useCallback((ctx: CanvasRenderingContext2D) => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    //fill color black
    ctx.fillStyle = 'black';
    // Set background color
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Draw fish character
    const fishPosition = drawPlayerPortrait(ctx, fishImageRef.current, gameState.portraitFishPositionRef.current);
    if (fishPosition) {
      // Create particles
      createPortraitParticles(gameState.portraitParticlesRef.current, fishPosition.x, fishPosition.y);
    }
    // Update and draw particles
    updateAndDrawParticles(ctx, gameState.portraitParticlesRef.current, 1);
  }, [gameState.portraitFishPositionRef, gameState.portraitParticlesRef, gameState.currentLevel.initialBackground]);

  // startGame callback (unchanged)
  const startGame = useCallback(() => {
    if (gameState.gameStarted) return;
    // Center the player horizontally before starting
    gameState.gameStateRef.current.player.y = window.innerHeight / 2;
    gameState.gameStateRef.current.player.x = 100;
    gameState.setGameStarted(true);
    gameState.setHealth(100);
    onGameStart?.();
    // Set up container background based on level
    if (gameState.currentLevel.id === 2 && gameState.containerRef.current) {
      gameState.containerRef.current.style.background = "transparent";
      // Make sure level 2 assets are loaded before starting
      if (gameState.level2ObstacleImagesRef.current.length === 0 ||
        gameState.level2PickupImagesRef.current.length === 0) {
        const loadLevel2 = async () => {
          await assetLoader.current.loadLevel2Assets();
          // Update level 2 asset refs
          gameState.level2ObstacleImagesRef.current = assetLoader.current.level2ObstacleImages;
          gameState.level2PickupImagesRef.current = assetLoader.current.level2PickupImages;
          startAudioAndGameLoop();
        };
        loadLevel2();
      } else {
        startAudioAndGameLoop();
      }
    } else if (gameState.currentLevel.id === 3 && gameState.containerRef.current) {
      // Make sure level 3 assets are loaded before starting
      if (gameState.level3ObstacleImagesRef.current.length === 0 ||
        gameState.level3MushroomImagesRef.current.length === 0 ||
        gameState.level3TrippyImagesRef.current.length === 0) {
        const loadLevel3 = async () => {
          await assetLoader.current.loadLevel3Assets();
          // Update level 3 asset refs
          gameState.level3ObstacleImagesRef.current = assetLoader.current.level3ObstacleImages;
          gameState.level3MushroomImagesRef.current = assetLoader.current.level3MushroomImages;
          gameState.level3TrippyImagesRef.current = assetLoader.current.level3TrippyImages;
          console.log('Level 3 assets loaded in startGame:', {
            obstacles: gameState.level3ObstacleImagesRef.current.length,
            mushrooms: gameState.level3MushroomImagesRef.current.length,
            trippyImages: gameState.level3TrippyImagesRef.current.length
          });
          startAudioAndGameLoop();
        };
        loadLevel3();
      } else {
        startAudioAndGameLoop();
      }
    } else {
      gameState.backgroundColorRef.current = gameState.currentLevel.initialBackground;
      gameState.waveColorRef.current = gameState.currentLevel.initialWaveColor;
      if (gameState.containerRef.current) {
        gameState.containerRef.current.style.background = gameState.currentLevel.initialBackground;
      }
      startAudioAndGameLoop();
    }
    
    function startAudioAndGameLoop() {
      // Reset color events
      gameState.colorEventsRef.current.forEach((event, index) => {
        event.triggered = index === 0;
      });
      // Reset color transition
      gameState.activeColorTransitionRef.current = {
        backgroundColor: "#1a1a2e",
        waveColor: "rgba(0,102,255,0.4)",
        progress: 1,
        targetBackgroundColor: "#1a1a2e",
        targetWaveColor: "rgba(0,102,255,0.4)",
        transitionDuration: 3
      };
      // Start audio and game loop with proper error handling
      if (audioRef.current) {
        // Reset any previous state
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
        // Check if the browser can play the audio type
        const canPlayType = audioRef.current.canPlayType(
          gameState.currentLevel.songFile.endsWith('.mp3') ? 'audio/mpeg' :
            gameState.currentLevel.songFile.endsWith('.wav') ? 'audio/wav' :
              gameState.currentLevel.songFile.endsWith('.ogg') ? 'audio/ogg' : ''
        );
        if (canPlayType === '') {
          console.warn(`Browser might not support the audio format: ${gameState.currentLevel.songFile}`);
        }
        // Ensure audio is properly loaded before playing
        audioRef.current.load();
        // Create a flag to prevent multiple initializations
        let initialized = false;
        // Handle canplaythrough event
        const handleCanPlay = () => {
          if (initialized || !audioRef.current) return;
          initialized = true;
          audioRef.current.currentTime = 0;
          // Start the game loop even if audio fails
          startGameLoop();
          // Try to play audio, but don't block the game if it fails
          audioRef.current.play().catch(error => {
            console.log("Audio play error:", error.message);
          });
        };
        
        // Set up the event listener
        audioRef.current.addEventListener('canplaythrough', handleCanPlay, { once: true });
        // Start game loop function to avoid code duplication
        const startGameLoop = () => {
          gameState.gameLoopRef.current = true;
          gameState.animationFrameIdRef.current = requestAnimationFrame(() =>
            gameLoop(
              canvasRef,
              gameState.gameStateRef,
              gameState.lastFrameTimeRef,
              gameState.gameLoopRef,
              gameState.animationFrameIdRef,
              audioRefNonNull,
              gameState.audioProgressRef,
              getAverageAmplitude,
              detectBeat,
              gameState.lastBeatTimeRef,
              inputRef,
              gameState.backgroundColorRef,
              gameState.waveColorRef,
              gameState.activeColorTransitionRef,
              gameState.bgPatternBubblesRef,
              gameState.levelTogglesRef,
              gameState.bubblesRef,
              gameState.amplitudeRef,
              gameState.activeTimedTextsRef,
              gameState.floraItemsRef,
              gameState.streakDisplayRef,
              fishImageRef,
              waterBottleRef,
              plasticBagRef,
              oilSplatImageRef,
              fishHookRef,
              flipflopRef,
              toothbrushRef,
              hotdogRef,
              rubberDuckyRef,
              gameState.level2ObstacleImagesRef,
              gameState.level2PickupImagesRef,
              gameState.level3ObstacleImagesRef,
              gameState.level3MushroomImagesRef,
              gameState.level3TrippyImagesRef,
              gameState.currentLevelRef,
              gameState.timedTextEventsRef,
              gameState.colorEventsRef,
              gameState.level2TimedEventsRef,
              gameState.level3TimedEventsRef,
              gameState.caveRef,
              gameState.speedMultiplier,
              gameState.setScore,
              gameState.setHealth,
              gameState.setLevelEnded,
              gameState.lastCollisionTimeRef,
              gameState.lastProximityScoreTimeRef,
              gameState.pickupSoundRef as React.RefObject<HTMLAudioElement>,
              gameState.hitSoundRef as React.RefObject<HTMLAudioElement>
            )
          );
        };
        // Fallback in case oncanplaythrough doesn't fire
        const timeoutId = setTimeout(() => {
          if (!initialized && audioRef.current) {
            console.log("Starting game loop via timeout fallback");
            audioRef.current.removeEventListener('canplaythrough', handleCanPlay);
            handleCanPlay();
          }
        }, 3000);
        // Cleanup function to prevent memory leaks
        return () => {
          if (audioRef.current) {
            audioRef.current.removeEventListener('canplaythrough', handleCanPlay);
          }
          clearTimeout(timeoutId);
        };
      }
    }
  }, [
    gameState,
    onGameStart,
    getAverageAmplitude,
    detectBeat,
    inputRef,
    audioRef
  ]);

  return (
    <div
      ref={gameState.containerRef}
      style={{
        position: 'relative',
        width: '100%',
        minHeight: '100vh',
        background: gameState.backgroundColorRef.current,
        fontFamily: 'Orbitron, sans-serif'
      }}
    >
      {gameState.currentLevel.id === 2 && (
        <video autoPlay loop muted style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          zIndex: -1
        }}>
          <source src="/videos/level2background-compressed.mp4" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
      )}

      <canvas
        ref={starsCanvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '200px',
          pointerEvents: 'none',
          zIndex: 5
        }}
      />

      <GameControls
        gameStarted={gameState.gameStarted}
        isPaused={gameState.isPaused}
        togglePause={gameState.togglePause}
        currentLevel={gameState.currentLevel}
        score={gameState.score}
        audioProgress={gameState.audioProgress}
        currentTime={gameState.currentTime}
        duration={gameState.duration}
      />

      {gameState.gameStarted && <HealthBar health={gameState.health} />}

      {gameState.gameStarted && (
        <StreakDisplay
          streak={gameState.gameStateRef.current.streak}
          multiplier={gameState.gameStateRef.current.multiplier}
          scale={gameState.streakDisplayRef.current.scale}
        />
      )}

      <WelcomeScreen
        gameStarted={gameState.gameStarted}
        isLandscape={gameState.isLandscape}
        floraLoaded={floraLoaded}
        startGame={startGame}
        setShowAboutModal={gameState.setShowAboutModal}
      />

      <PortraitScreen
        isPortrait={!gameState.isLandscape}
        gameStarted={gameState.gameStarted}
        isPaused={gameState.isPaused}
        setShowAboutModal={gameState.setShowAboutModal}
        animatePortrait={animatePortrait}
      />

      <canvas
        ref={canvasRef}
        style={{ width: '100%', height: '100%', display: 'block' }}
      />

      <audio
        id="audioControl"
        ref={audioRef}
        crossOrigin="anonymous"
        style={{ display: 'none' }}
      >
        <source src={gameState.currentLevel.songFile} type="audio/mpeg" />
        Your browser does not support the audio element.
      </audio>

      <PauseScreen
        isPaused={gameState.isPaused}
        levelEnded={gameState.levelEnded}
        isLandscape={gameState.isLandscape}
        currentLevel={gameState.currentLevel}
        pendingLevel={gameState.pendingLevel}
        levels={gameState.levels}
        togglePause={gameState.togglePause}
        setPendingLevel={gameState.setPendingLevel}
        selectLevel={gameState.selectLevel}
        restartGameLoop={restartGameLoop}
      />

      <LevelCompleteScreen
        levelEnded={gameState.levelEnded}
        health={gameState.health}
        score={gameState.score}
        gameState={gameState.gameStateRef.current}
        levels={gameState.levels}
        currentLevel={gameState.currentLevel}
        selectLevel={gameState.selectLevel}
        setLevelEnded={gameState.setLevelEnded}
        setGameStarted={gameState.setGameStarted}
        restartGameLoop={restartGameLoop}
      />

      <AboutModal
        showAboutModal={gameState.showAboutModal}
        setShowAboutModal={gameState.setShowAboutModal}
      />
    </div>
  );
};

export default MusicReactiveOceanGame;

================
File: src/hooks/useAudio.ts
================
// src/hooks/useAudio.ts
import { useRef, useEffect } from 'react';
import { ExtendedHTMLAudioElement } from '../types';

export const useAudio = (
  gameStarted: boolean,
  isPaused: boolean,
  setAudioProgress: (progress: number) => void,
  setCurrentTime: (time: number) => void,
  setDuration: (duration: number) => void,
  setLevelEnded: (ended: boolean) => void,
  gameLoopRef: React.MutableRefObject<boolean>,
  animationFrameIdRef: React.MutableRefObject<number | null>,
  analyserRef: React.MutableRefObject<AnalyserNode | null>,
  dataArrayRef: React.MutableRefObject<Uint8Array | null>,
  lastBeatTimeRef: React.MutableRefObject<number>,
  currentLevelId: number // <-- new parameter to trigger re-setup when level changes
) => {
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const fallbackTimerRef = useRef<number | null>(null);

  // When no audio data is detected, update the last beat time every 500ms.
  const startFallbackBeatGeneration = () => {
    if (fallbackTimerRef.current) return; // Don't start if already running
    const BPM = 120; // Beats per minute
    const interval = 60000 / BPM; 
   // console.log(`[DEBUG] Starting fallback beat generator at ${BPM} BPM (${interval}ms)`);
    fallbackTimerRef.current = window.setInterval(() => {
      lastBeatTimeRef.current = Date.now();
    //  console.log('[DEBUG] Fallback beat generated');
    }, interval);
  };
  useEffect(() => {
    if (!gameStarted) return;
    const audioEl = audioRef.current as ExtendedHTMLAudioElement;
    if (!audioEl) return;
    const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
    if (!AudioContextClass) {
      console.error("Web Audio API not supported.");
      return;
    }
    const setupAudio = async () => {
      try {
        const audioCtx = audioEl._audioCtx || new AudioContextClass();
        audioEl._audioCtx = audioCtx;
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.2;
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        analyserRef.current = analyser;
        const bufferLength = analyser.frequencyBinCount;
        dataArrayRef.current = new Uint8Array(bufferLength);
  
        if (!audioEl._mediaElementSource) {
      //    console.log('[DEBUG] Creating new media element source');
          const source = audioCtx.createMediaElementSource(audioEl);
          audioEl._mediaElementSource = source;
        } else {
        //  console.log('[DEBUG] Reusing existing media element source');
          audioEl._mediaElementSource.disconnect();
        }
        audioEl._mediaElementSource.connect(analyser);
        analyser.connect(audioCtx.destination);
  
        if (audioCtx.state !== 'running') {
       //   console.log('[DEBUG] Resuming AudioContext...');
          await audioCtx.resume();
          //console.log('[DEBUG] AudioContext state after resume:', audioCtx.state);
        }
      //  console.log('[DEBUG] Audio setup complete - Analyzer created with bufferLength:', bufferLength);
        setTimeout(() => {
          if (analyserRef.current && dataArrayRef.current) {
            analyserRef.current.getByteFrequencyData(dataArrayRef.current);
            let sum = 0;
            for (let i = 0; i < dataArrayRef.current.length; i++) {
              sum += dataArrayRef.current[i];
            }
          //  console.log('[DEBUG] Initial audio data test:', sum > 0 ? 'RECEIVING DATA ✅' : 'NO DATA ❌');
            if (sum === 0) {
          //    console.log('[DEBUG] No audio data detected, activating fallback beat generation');
              startFallbackBeatGeneration();
            }
          }
        }, 1000);
      } catch (error) {
        console.error("Error setting up audio:", error);
        startFallbackBeatGeneration();
      }
    };
  
    const handlePlay = () => {
      setupAudio();
    };
    audioEl.addEventListener('play', handlePlay);
    const resumeAudioCtx = async () => {
      if (audioEl._audioCtx && audioEl._audioCtx.state !== 'running') {
        try {
          await audioEl._audioCtx.resume();
     //     console.log('[DEBUG] AudioContext resumed from user interaction');
        } catch (error) {
       //   console.error('[DEBUG] Error resuming AudioContext:', error);
        }
      }
    };
    document.body.addEventListener('touchstart', resumeAudioCtx, { once: true });
    document.body.addEventListener('click', resumeAudioCtx, { once: true });
    document.body.addEventListener('keydown', resumeAudioCtx, { once: true });
    return () => {
      audioEl.removeEventListener('play', handlePlay);
      document.body.removeEventListener('touchstart', resumeAudioCtx);
      document.body.removeEventListener('click', resumeAudioCtx);
      document.body.removeEventListener('keydown', resumeAudioCtx);
      if (fallbackTimerRef.current) {
        clearInterval(fallbackTimerRef.current);
        fallbackTimerRef.current = null;
      }
    };
  }, [gameStarted, currentLevelId, isPaused]);
  
  useEffect(() => {
    if (!gameStarted) return;
    const updateProgress = () => {
      if (audioRef.current) {
        const curTime = audioRef.current.currentTime;
        const dur = audioRef.current.duration;
        if (dur) {
          setAudioProgress((curTime / dur) * 100);
          setCurrentTime(curTime);
          setDuration(dur);
          if (dur - curTime < 0.1) {
            setLevelEnded(true);
            gameLoopRef.current = false;
            if (animationFrameIdRef.current) {
              cancelAnimationFrame(animationFrameIdRef.current);
              animationFrameIdRef.current = null;
            }
          }
        }
      }
    };
    const intervalId = setInterval(updateProgress, 100);
    return () => clearInterval(intervalId);
  }, [gameStarted, setAudioProgress, setCurrentTime, setDuration, setLevelEnded, gameLoopRef, animationFrameIdRef]);

  useEffect(() => {
    if (!audioRef.current || !gameStarted) return;
    if (isPaused) {
      audioRef.current.pause();
      if (fallbackTimerRef.current) {
        clearInterval(fallbackTimerRef.current);
        fallbackTimerRef.current = null;
      }
    } else {
      audioRef.current.play().catch(error => {
        if (error.name === 'AbortError') return;
        console.error("Error playing audio:", error);
        if (!fallbackTimerRef.current) {
          const BPM = 120;
          const interval = 60000 / BPM;
          fallbackTimerRef.current = window.setInterval(() => {}, interval);
        }
      });
    }
  }, [isPaused, gameStarted]);

  const getAverageAmplitude = (): number => {
    const analyser = analyserRef.current;
    const dataArray = dataArrayRef.current;
    if (!analyser || !dataArray) {
    //  console.log('[DEBUG] getAverageAmplitude: Analyzer or dataArray not available');
      return 0;
    }
    try {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      let count = 0;
      const rangeEnd = Math.floor(dataArray.length / 4);
      for (let i = 0; i < rangeEnd; i++) {
        sum += dataArray[i];
        count++;
      }
      const avg = count > 0 ? sum / count : 0;
      if (Math.random() < 0.05) {
    //    console.log(`[DEBUG] Current amplitude: ${avg.toFixed(2)}, from ${count} frequency bins`);
      }
      return avg;
    } catch (error) {
     // console.error("[DEBUG] Error getting amplitude:", error);
      return 0;
    }
  };

  const detectBeat = (amplitude: number, lastBeatTimeRefParam: React.MutableRefObject<number>): boolean => {
    const now = Date.now();
    const beatThreshold = 10;
    const minTimeBetweenBeats = 300;
    const forceBeatInterval = 800;
    const timeSinceLastBeat = now - lastBeatTimeRefParam.current;
    if (timeSinceLastBeat > forceBeatInterval) {
    //  console.log('[DEBUG] Generating fallback beat after timeout');
      lastBeatTimeRefParam.current = now;
      return true;
    }
    if (amplitude > beatThreshold && timeSinceLastBeat > minTimeBetweenBeats) {
      lastBeatTimeRefParam.current = now;
    //  console.log('[DEBUG] 🎵 Beat detected from audio!');
      return true;
    }
    return false;
  };

  return {
    audioRef,
    getAverageAmplitude,
    detectBeat
  };
};

================
File: src/hooks/useGameState.ts
================
import { useState, useRef, useEffect, useCallback } from 'react';
import { GameState, Level, LevelToggles, ActiveTimedText, ActiveColor, CaveState, Bubble, Flora, StreakDisplay, TimedTextEvent, TimedColorEvent, Level2TimedEvents, Level3TimedEvents, Particle } from '../types';
import { getDefaultLevels, createDefaultTimedTextEvents, createLevel2TimedTextEvents, createLevel3TimedTextEvents, createColorEventsByLevel, createLevel2TimedEvents, createLevel3TimedEvents, getInitialLevelToggles } from '../utils/eventData';
import { AssetLoader } from '../utils/assetLoader';

// Add a reference to the restartGameLoop function
export const useGameState = () => {
  // Game progress
  const [score, setScore] = useState(0);
  const [gameStarted, setGameStarted] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [audioProgress, setAudioProgress] = useState(0);
  const [levelEnded, setLevelEnded] = useState(false);
  const [health, setHealth] = useState(100);
  const [isLandscape, setIsLandscape] = useState(window.innerWidth > window.innerHeight);
  const [showAboutModal, setShowAboutModal] = useState(false);
  const [pendingLevel, setPendingLevel] = useState<Level | null>(null);
  const [pausedByOrientation, setPausedByOrientation] = useState(false);

  // Store the restartGameLoop function reference
  const restartGameLoopRef = useRef<(() => void) | null>(null);

  // Audio progress ref for use in callback functions
  const audioProgressRef = useRef(0);

  // Game levels
  const [levels, setLevels] = useState<Level[]>(() => {
    const savedLevels = localStorage.getItem('gameLevels');
    const defaultLevels = getDefaultLevels();
    if (savedLevels) {
      try {
        const parsedLevels = JSON.parse(savedLevels);
        return defaultLevels.map(defaultLevel => {
          const savedLevel = parsedLevels.find((level: Level) => level.id === defaultLevel.id);
          if (savedLevel) {
            return {
              ...defaultLevel,
              highScore: Math.max(savedLevel.highScore || 0, defaultLevel.highScore || 0),
              highestStreak: Math.max(savedLevel.highestStreak || 0, defaultLevel.highestStreak || 0)
            };
          }
          return defaultLevel;
        });
      } catch (e) {
        console.error("Error parsing saved levels:", e);
        return defaultLevels;
      }
    }
    return defaultLevels;
  });

  // Current level state
  const [currentLevel, setCurrentLevel] = useState<Level>(levels[0]);
  const currentLevelRef = useRef(currentLevel);

  // Game state
  const gameStateRef = useRef<GameState>({
    player: {
      x: 100,
      y: window.innerHeight / 2,
      width: 50,
      height: 30,
      speed: 5,
      rotation: 0,
      spinRotation: 0,
      vy: 0,
      hitTime: undefined,
      hitType: undefined
    },
    pickups: [],
    obstacles: [],
    particles: [],
    score: 0,
    scorePopups: [],
    trashStats: { totalSpawned: 0, collected: 0, missed: 0 },
    streak: 0,
    multiplier: 1,
    highestStreak: 0,
    time: 0,
    paused: false,
    gameOver: false,
    gameStarted: false,
    gameEnded: false,
    gameItems: [],
    levelToggles: getInitialLevelToggles(),
    highScore: 0,
    level: levels[0],
    timedTextEvents: [],
    activeTimedText: { text: "", lifetime: 0 } as ActiveTimedText,
    timedColorEvents: [],
    activeColor: {
      backgroundColor: "#1a1a2e",
      waveColor: "rgba(0,102,255,0.4)",
      progress: 1,
      targetBackgroundColor: "#1a1a2e",
      targetWaveColor: "rgba(0,102,255,0.4)",
      transitionDuration: 3,
    },
    bubbles: [],
    flora: [],
    streakDisplay: {
      x: 0,
      y: 0,
      scale: 1,
      opacity: 1
    }
  });

  // Audio refs
  const pickupSoundRef = useRef<HTMLAudioElement | null>(null);
  const hitSoundRef = useRef<HTMLAudioElement | null>(null);

  // Animation and game loop refs
  const gameLoopRef = useRef<boolean>(false);
  const animationFrameIdRef = useRef<number | null>(null);
  const lastFrameTimeRef = useRef<number>(performance.now());
  const lastBeatTimeRef = useRef<number>(0);
  const lastCollisionTimeRef = useRef<number>(0);
  const lastProximityScoreTimeRef = useRef<number>(0);

  // Audio analyzer refs
  const analyserRef = useRef<AnalyserNode | null>(null);
  const dataArrayRef = useRef<Uint8Array | null>(null);
  const amplitudeRef = useRef<number>(0);

  // Color references
  const backgroundColorRef = useRef("#FDF200");
  const waveColorRef = useRef("rgba(253,242,0,0.4)");

  // Dynamic game elements
  const levelTogglesRef = useRef<LevelToggles>(getInitialLevelToggles());
  const activeTimedTextsRef = useRef<ActiveTimedText[]>([]);
  const speedMultiplier = useRef<number>(1);
  const bubblesRef = useRef<Bubble[]>([]);
  const floraItemsRef = useRef<Flora[]>([]);
  const bgPatternBubblesRef = useRef<Bubble[]>([]);
  const streakDisplayRef = useRef<StreakDisplay>({
    x: 0,
    y: 0,
    scale: 1,
    opacity: 1
  });

  // Cave mechanics
  const caveRef = useRef<CaveState>({
    upper: { points: [], amplitude: 0 },
    lower: { points: [], amplitude: 0 }
  });

  // Event references
  const timedTextEventsRef = useRef<TimedTextEvent[]>(createDefaultTimedTextEvents());
  const colorEventsRef = useRef<TimedColorEvent[]>(createColorEventsByLevel(1)); // Default to level 1
  const level2TimedEventsRef = useRef<Level2TimedEvents>(createLevel2TimedEvents());
  const level3TimedEventsRef = useRef<Level3TimedEvents>(createLevel3TimedEvents());
  const activeColorTransitionRef = useRef<ActiveColor>({
    backgroundColor: "#1a1a2e",
    waveColor: "rgba(0,102,255,0.4)",
    progress: 1,
    targetBackgroundColor: "#1a1a2e",
    targetWaveColor: "rgba(0,102,255,0.4)",
    transitionDuration: 3
  });

  // Portrait mode animation refs
  const portraitParticlesRef = useRef<Particle[]>([]);
  const portraitAnimationFrameRef = useRef<number | null>(null);
  const portraitFishPositionRef = useRef({ x: 0, y: 0, rotation: 0 });

  useEffect(() => {
    currentLevelRef.current = currentLevel;
  }, [currentLevel]);

  useEffect(() => {
    audioProgressRef.current = audioProgress;
  }, [audioProgress]);

  useEffect(() => {
    setLevels(prev => {
      const newLevels = prev.map(level => {
        if (level.id === currentLevel.id) {
          const newHighScore = Math.max(level.highScore || 0, score);
          const newHighestStreak = Math.max(level.highestStreak || 0, gameStateRef.current.highestStreak);
          return { ...level, highScore: newHighScore, highestStreak: newHighestStreak };
        }
        return level;
      });
      localStorage.setItem('gameLevels', JSON.stringify(newLevels));
      const updatedCurrent = newLevels.find(l => l.id === currentLevel.id);
      if (updatedCurrent) {
        setCurrentLevel(updatedCurrent);
      }
      return newLevels;
    });
  }, [score, currentLevel.id]);

  useEffect(() => {
    const handleOrientationChange = () => {
      const landscape = window.innerWidth > window.innerHeight;
      setIsLandscape(landscape);
      if (landscape) {
        gameStateRef.current.player.y = window.innerHeight / 2;
      }
    };
    window.addEventListener('resize', handleOrientationChange);
    return () => window.removeEventListener('resize', handleOrientationChange);
  }, []);

  useEffect(() => {
    if (!isLandscape && gameStarted && !isPaused) {
      togglePause();
      setPausedByOrientation(true);
    }
  }, [isLandscape, gameStarted, isPaused]);

  useEffect(() => {
    if (isLandscape && pausedByOrientation && gameStarted && isPaused) {
      togglePause();
      setPausedByOrientation(false);
    }
  }, [isLandscape, pausedByOrientation, gameStarted, isPaused]);

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const levelParam = params.get("level");
    if (levelParam === "2") {
      const level2 = levels.find(l => l.id === 2);
      if (level2) {
        (async () => {
          await selectLevel(level2);
        })();
      }
    } else if (levelParam === "3") {
      const level3 = levels.find(l => l.id === 3);
      if (level3) {
        (async () => {
          await selectLevel(level3);
        })();
      }
    }
  }, [levels]);
  

  useEffect(() => {
    const font = new FontFace('Orbitron', 'url(/fonts/Orbitron/Orbitron-VariableFont_wght.ttf)');
    font.load().then(() => {
      document.fonts.add(font);
    });
  }, []);

  const containerRef = useRef<HTMLDivElement | null>(null);

  const level2ObstacleImagesRef = useRef<HTMLImageElement[]>([]);
  const level2PickupImagesRef = useRef<HTMLImageElement[]>([]);
  const level3ObstacleImagesRef = useRef<HTMLImageElement[]>([]);
  const level3MushroomImagesRef = useRef<HTMLImageElement[]>([]);
  const level3TrippyImagesRef = useRef<HTMLImageElement[]>([]);

  const togglePause = useCallback(() => {
    setIsPaused(prev => {
      const newPaused = !prev;
      gameStateRef.current.player.x = 100;
      if (newPaused) {
        gameLoopRef.current = false;
        if (animationFrameIdRef.current) {
          cancelAnimationFrame(animationFrameIdRef.current);
          animationFrameIdRef.current = null;
        }
      } else {
        gameLoopRef.current = true;
        // Call the restartGameLoop function from the parent component
        if (restartGameLoopRef.current) {
          restartGameLoopRef.current();
        }
      }
      return newPaused;
    });
  }, []);

  const selectLevel = useCallback(async (level: Level) => {
    if (!level.unlocked) return;
    gameLoopRef.current = false;
    if (animationFrameIdRef.current) {
      cancelAnimationFrame(animationFrameIdRef.current);
      animationFrameIdRef.current = null;
    }
    gameStateRef.current = {
      player: {
        x: (window.innerWidth / 2) - 25,
        y: window.innerHeight / 2,
        width: 50,
        height: 30,
        speed: 5,
        rotation: 0,
        spinRotation: 0,
        vy: 0,
        hitTime: undefined,
        hitType: undefined
      },
      pickups: [],
      obstacles: [],
      particles: [],
      score: 0,
      scorePopups: [],
      trashStats: { totalSpawned: 0, collected: 0, missed: 0 },
      streak: 0,
      multiplier: 1,
      highestStreak: 0,
      time: 0,
      paused: false,
      gameOver: false,
      gameStarted: gameStateRef.current.gameStarted,
      gameEnded: false,
      gameItems: [],
      levelToggles: getInitialLevelToggles(),
      highScore: level.highScore || 0,
      level: level,
      timedTextEvents: [],
      activeTimedText: { text: "", lifetime: 0, color: 'black' },
      timedColorEvents: [],
      activeColor: {
        backgroundColor: level.initialBackground || "#1a1a2e",
        waveColor: level.initialWaveColor || "rgba(0,102,255,0.4)",
        progress: 1,
        targetBackgroundColor: level.initialBackground || "#1a1a2e",
        targetWaveColor: level.initialWaveColor || "rgba(0,102,255,0.4)",
        transitionDuration: 3
      },
      bubbles: [],
      flora: [],
      streakDisplay: {
        x: 0,
        y: 0,
        scale: 1,
        opacity: 1
      }
    };
    caveRef.current = {
      upper: { points: [], amplitude: 0 },
      lower: { points: [], amplitude: 0 }
    };
    activeTimedTextsRef.current = [];
    timedTextEventsRef.current = timedTextEventsRef.current.map(event => ({
      ...event,
      triggered: false
    }));
    // Update color events for the selected level
    colorEventsRef.current = createColorEventsByLevel(level.id).map(event => ({
      ...event,
      triggered: event.timestamp === 0
    }));
    setCurrentLevel(level);
  
    if (level.id === 2) {
      if (containerRef.current) {
        containerRef.current.style.background = "transparent";
      }
      timedTextEventsRef.current = createLevel2TimedTextEvents();
      const loadLevel2Assets = async () => {
        if (gameStateRef.current.gameStarted) {
          setIsPaused(true);
        }
        const assetLoader = new AssetLoader();
        await assetLoader.loadLevel2Assets();
        level2ObstacleImagesRef.current = assetLoader.level2ObstacleImages;
        level2PickupImagesRef.current = assetLoader.level2PickupImages;
        setLevelEnded(false);
        setHealth(100);
        if (gameStateRef.current.gameStarted) {
          setIsPaused(false);
          // When unpausing after level change, make sure the game loop restarts
          gameLoopRef.current = true;
          // Call the restartGameLoop function if it exists
          if (restartGameLoopRef.current) {
            restartGameLoopRef.current();
          }
        }
      };
      // Await the level‑2 assets to ensure they're fully loaded before continuing
      await loadLevel2Assets();
    } else if (level.id === 3) {
      if (containerRef.current) {
        containerRef.current.style.background = "transparent";
      }
      timedTextEventsRef.current = createLevel3TimedTextEvents();
      const loadLevel3Assets = async () => {
        if (gameStateRef.current.gameStarted) {
          setIsPaused(true);
        }
        const assetLoader = new AssetLoader();
        await assetLoader.loadLevel3Assets();
        level3ObstacleImagesRef.current = assetLoader.level3ObstacleImages;
        level3MushroomImagesRef.current = assetLoader.level3MushroomImages;
        level3TrippyImagesRef.current = assetLoader.level3TrippyImages;
        setLevelEnded(false);
        setHealth(100);
        if (gameStateRef.current.gameStarted) {
          setIsPaused(false);
          // When unpausing after level change, make sure the game loop restarts
          gameLoopRef.current = true;
          // Call the restartGameLoop function if it exists
          if (restartGameLoopRef.current) {
            restartGameLoopRef.current();
          }
        }
      };
      // Await the level‑3 assets to ensure they're fully loaded before continuing
      await loadLevel3Assets();
    } else {
      backgroundColorRef.current = level.initialBackground;
      waveColorRef.current = level.initialWaveColor;
      if (containerRef.current) {
        containerRef.current.style.background = level.initialBackground;
      }
      timedTextEventsRef.current = createDefaultTimedTextEvents();
      setLevelEnded(false);
      setHealth(100);
      
      // For level 1 or any other level, make sure the game loop restarts if game has started
      if (gameStateRef.current.gameStarted) {
        gameLoopRef.current = true;
        // Call the restartGameLoop function if it exists
        if (restartGameLoopRef.current) {
          restartGameLoopRef.current();
        }
      }
    }
  }, [levels, setIsPaused, setLevelEnded, setHealth]);
  
  // Function to set the restart game loop reference
  const setRestartGameLoopRef = useCallback((fn: () => void) => {
    restartGameLoopRef.current = fn;
  }, []);

  return {
    score,
    setScore,
    gameStarted,
    setGameStarted,
    isPaused,
    setIsPaused,
    currentTime,
    setCurrentTime,
    duration,
    setDuration,
    audioProgress,
    setAudioProgress,
    levelEnded,
    setLevelEnded,
    health,
    setHealth,
    isLandscape,
    showAboutModal,
    setShowAboutModal,
    pendingLevel,
    setPendingLevel,
    pausedByOrientation,
    setPausedByOrientation,
    levels,
    setLevels,
    currentLevel,
    setCurrentLevel,
    containerRef,
    gameStateRef,
    currentLevelRef,
    gameLoopRef,
    animationFrameIdRef,
    audioProgressRef,
    lastFrameTimeRef,
    lastBeatTimeRef,
    lastCollisionTimeRef,
    lastProximityScoreTimeRef,
    analyserRef,
    dataArrayRef,
    amplitudeRef,
    backgroundColorRef,
    waveColorRef,
    levelTogglesRef,
    activeTimedTextsRef,
    speedMultiplier,
    bubblesRef,
    floraItemsRef,
    bgPatternBubblesRef,
    streakDisplayRef,
    caveRef,
    timedTextEventsRef,
    colorEventsRef,
    level2TimedEventsRef,
    level3TimedEventsRef,
    activeColorTransitionRef,
    portraitParticlesRef,
    portraitAnimationFrameRef,
    portraitFishPositionRef,
    pickupSoundRef,
    hitSoundRef,
    level2ObstacleImagesRef,
    level2PickupImagesRef,
    level3ObstacleImagesRef,
    level3MushroomImagesRef,
    level3TrippyImagesRef,
    togglePause,
    selectLevel,
    // Game loop integration
    setRestartGameLoopRef
  };
};

================
File: src/hooks/useInputHandler.ts
================
import { useRef, useEffect } from 'react';

// Define the InputState interface
interface InputState {
  isTouching: boolean;
  touchY: number;
  isDesktop: boolean;
}

export const useInputHandlers = (canvasRef: React.RefObject<HTMLCanvasElement>) => {
  // Input state
  const inputRef = useRef<InputState>({
    isTouching: false,
    touchY: window.innerHeight / 2,
    isDesktop: false,
  });

  // Set up input event listeners
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Determine if device has coarse pointing (touch) or fine pointing (mouse)
    const hasCoarse = window.matchMedia('(pointer: coarse)').matches;
    inputRef.current.isDesktop = !hasCoarse;
    
    const handleMouseMove = (e: MouseEvent) => {
      if (inputRef.current.isDesktop) {
        inputRef.current.touchY = e.clientY;
      } else if (inputRef.current.isTouching) {
        inputRef.current.touchY = e.clientY;
      }
    };
    
    const handleTouchMove = (e: TouchEvent) => {
      if (inputRef.current.isTouching) {
        inputRef.current.touchY = e.touches[0].clientY;
      }
      e.preventDefault();
    };
    
    const handleTouchStart = (e: TouchEvent) => {
      inputRef.current.isTouching = true;
      inputRef.current.touchY = e.touches[0].clientY;
      e.preventDefault();
    };
    
    const handleTouchEnd = (e: TouchEvent) => {
      inputRef.current.isTouching = false;
      e.preventDefault();
    };
    
    // Add different event listeners based on device capabilities
    if (!hasCoarse) {
      // Desktop/mouse events
      canvas.addEventListener('mousemove', handleMouseMove);
    } else {
      // Mobile/touch events
      canvas.addEventListener('mousedown', () => inputRef.current.isTouching = true);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', () => inputRef.current.isTouching = false);
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
    }
    
    // Clean up event listeners
    return () => {
      if (!hasCoarse) {
        canvas.removeEventListener('mousemove', handleMouseMove);
      } else {
        canvas.removeEventListener('mousedown', () => inputRef.current.isTouching = true);
        canvas.removeEventListener('mousemove', handleMouseMove);
        canvas.removeEventListener('mouseup', () => inputRef.current.isTouching = false);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
        canvas.removeEventListener('touchend', handleTouchEnd);
      }
    };
  }, [canvasRef]);

  // Handle visibility change to pause game when tab is unfocused
  const setupVisibilityHandler = (isPaused: boolean, gameStarted: boolean, togglePause: () => void) => {
    useEffect(() => {
      const handleVisibilityChange = () => {
        if (document.hidden && !isPaused && gameStarted) {
          togglePause();
        }
      };
      
      document.addEventListener('visibilitychange', handleVisibilityChange);
      
      return () => {
        document.removeEventListener('visibilitychange', handleVisibilityChange);
      };
    }, [isPaused, gameStarted, togglePause]);
  };

  return {
    inputRef,
    setupVisibilityHandler
  };
};

================
File: src/utils/assetLoader.ts
================
// Class to handle asset loading with promises
export class AssetLoader {
  // Main game assets
  fishImage: HTMLImageElement | null = null;
  waterBottleImage: HTMLImageElement | null = null;
  plasticBagImage: HTMLImageElement | null = null;
  oilSplatImage: HTMLImageElement | null = null;
  fishHookImage: HTMLImageElement | null = null;
  flipflopImage: HTMLImageElement | null = null;
  toothbrushImage: HTMLImageElement | null = null;
  hotdogImage: HTMLImageElement | null = null;
  rubberDuckyImage: HTMLImageElement | null = null;
  
  // Level 2 specific assets
  busImage: HTMLImageElement | null = null;
  batsImage: HTMLImageElement | null = null;
  chickenImage: HTMLImageElement | null = null;
  vitaminCImage: HTMLImageElement | null = null;
  pillImage: HTMLImageElement | null = null;
  gingerImage: HTMLImageElement | null = null;
  tumericImage: HTMLImageElement | null = null;
  
  // Level 3 specific assets
  cloudImage: HTMLImageElement | null = null;
  eagleImage: HTMLImageElement | null = null;
  
  // Collections
  floraImages: HTMLImageElement[] = [];
  level2ObstacleImages: HTMLImageElement[] = [];
  level2PickupImages: HTMLImageElement[] = [];
  level3ObstacleImages: HTMLImageElement[] = [];
  level3MushroomImages: HTMLImageElement[] = [];
  level3TrippyImages: HTMLImageElement[] = [];
  
  // Sound effects
  pickupSound: HTMLAudioElement | null = null;
  hitSound: HTMLAudioElement | null = null;
  
  // Status flags
  floraLoaded = false;
  level2AssetsLoaded = false;
  level2VideoLoaded = false;
  level3AssetsLoaded = false;


  constructor() {}

  // Load basic game assets
  async loadBasicAssets(): Promise<void> {
    const assetPromises = [
      this.loadImage('/sprites/cvcheFish.webp').then(img => this.fishImage = img),
      this.loadImage('/sprites/waterBottle.webp').then(img => this.waterBottleImage = img),
      this.loadImage('/sprites/plasticBag.webp').then(img => this.plasticBagImage = img),
      this.loadImage('/sprites/oilSplat.webp').then(img => this.oilSplatImage = img),
      this.loadImage('/sprites/fishHook.webp').then(img => this.fishHookImage = img),
      this.loadImage('/sprites/flipflop.webp').then(img => this.flipflopImage = img),
      this.loadImage('/sprites/toothbrush.webp').then(img => this.toothbrushImage = img),
      this.loadImage('/sprites/hotdog.webp').then(img => this.hotdogImage = img),
      this.loadImage('/sprites/rubberDucky.webp').then(img => this.rubberDuckyImage = img),
      this.loadAudio('/sounds/pickup.mp3', 0.3).then(audio => this.pickupSound = audio),
      this.loadAudio('/sounds/hit.mp3', 0.3).then(audio => this.hitSound = audio)
    ];

    await Promise.all(assetPromises);
  }

  // Load flora images
  async loadFloraAssets(): Promise<void> {
    const floraFileNames = ['1 (1).webp', ...Array.from({ length: 20 }, (_, i) => `1 (${i + 16}).webp`)];
    const floraPromises = floraFileNames.map(fileName => 
      this.loadImage(`/sprites/flora/${fileName}`).then(img => this.floraImages.push(img))
    );
    
    await Promise.all(floraPromises);
    this.floraLoaded = true;
  }

  // Load level 2 specific assets
  async loadLevel2Assets(): Promise<void> {
    const obstaclePromises = [
      this.loadImage('/sprites/level2/obstacles/bus.webp').then(img =>  {
        this.busImage = img;
        this.level2ObstacleImages.push(img);
      }),
      this.loadImage('/sprites/level2/obstacles/bats.webp').then(img => {
        this.batsImage = img;
        this.level2ObstacleImages.push(img);
      }),
      this.loadImage('/sprites/level2/obstacles/chicken.webp').then(img => {
        this.chickenImage = img;
        this.level2ObstacleImages.push(img);
      })
    ];

    const pickupPromises = [
      this.loadImage('/sprites/level2/pickups/vitaminC.webp').then(img => {
        this.vitaminCImage = img;
        this.level2PickupImages.push(img);
      }),
      this.loadImage('/sprites/level2/pickups/pill.webp').then(img => {
        this.pillImage = img;
        this.level2PickupImages.push(img);
      }),
      this.loadImage('/sprites/level2/pickups/tumeric.webp').then(img => {
        this.tumericImage = img;
        this.level2PickupImages.push(img);
      }),
      this.loadImage('/sprites/level2/pickups/ginger.webp').then(img => {
        this.gingerImage = img;
        this.level2PickupImages.push(img);
      })
    ];

    const videoPromise = this.preloadVideo('/videos/level2background-compressed.mp4');

    await Promise.all([...obstaclePromises, ...pickupPromises, videoPromise]);
    this.level2AssetsLoaded = true;
  }
  
  // Load level 3 specific assets
  async loadLevel3Assets(): Promise<void> {
    // Load obstacle images
    const obstaclePromises = [
      this.loadImage('/sprites/level3/obstacles/clouds.webp').then(img => {
        this.cloudImage = img;
        this.level3ObstacleImages.push(img);
      }),
      this.loadImage('/sprites/level3/obstacles/eagle.webp').then(img => {
        this.eagleImage = img;
        this.level3ObstacleImages.push(img);
      })
    ];
  console.log('Loading level 3 assets... level3ObstacleImages: ',this.level3ObstacleImages);
    // Load mushroom images
    const mushroomPromises = [];
    for (let i = 1; i <= 9; i++) {
      mushroomPromises.push(
        this.loadImage(`/sprites/level3/mushrooms/mushroom (${i}).webp`).then(img => {
          this.level3MushroomImages.push(img);
        })
      );
    }
    
    // Load trippy images
    const trippyTypes = [
      'baby', 'baby2', 'blueMan', 'gummyWorm', 'kitten', 
      'magicRabbit', 'pomeranian', 'squirtToy', 'woman'
    ];
    
    const trippyPromises = trippyTypes.map(type => {
      const ext = type === 'blueMan' ? 'jpg' : 'png'; // blueMan is jpg, others are png
      return this.loadImage(`/sprites/level3/trippyPickups/${type}.${ext}`).then(img => {
        this.level3TrippyImages.push(img);
      });
    });
    
    await Promise.all([...obstaclePromises, ...mushroomPromises, ...trippyPromises]);
    this.level3AssetsLoaded = true;
  }

  // Helper method to load an image
  private loadImage(src: string): Promise<HTMLImageElement> {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = src;
    });
  }

  // Helper method to load audio
  private loadAudio(src: string, volume: number = 1.0): Promise<HTMLAudioElement> {
    return new Promise((resolve) => {
      const audio = new Audio(src);
      audio.volume = volume;
      audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
      audio.load();
    });
  }

  // Preload video for level 2
  private preloadVideo(src: string): Promise<void> {
    return new Promise((resolve) => {
      const video = document.createElement('video');
      video.src = src;
      video.muted = true;
      video.playsInline = true; // Important for iOS
      video.preload = 'auto';
      video.onloadeddata = () => {
        this.level2VideoLoaded = true;
        resolve();
      };
      video.load();
    });
  }
}

================
File: src/utils/colorUtils.ts
================
/**
 * Interpolates between two colors based on a factor (0-1)
 * Works with both hex colors (#RRGGBB) and rgba colors
 */
export const interpolateColor = (color1: string, color2: string, factor: number): string => {
    if (color1.startsWith('rgba') && color2.startsWith('rgba')) {
      const c1 = color1.match(/[\d.]+/g)?.map(Number) || [];
      const c2 = color2.match(/[\d.]+/g)?.map(Number) || [];
      return `rgba(${Math.round(c1[0] + (c2[0] - c1[0]) * factor)},${Math.round(c1[1] + (c2[1] - c1[1]) * factor)},${Math.round(c1[2] + (c2[2] - c1[2]) * factor)},${c1[3] + (c2[3] - c1[3]) * factor})`;
    }
  
    const c1 = parseInt(color1.slice(1), 16);
    const c2 = parseInt(color2.slice(1), 16);
    const r1 = (c1 >> 16) & 255;
    const g1 = (c1 >> 8) & 255;
    const b1 = c1 & 255;
    const r2 = (c2 >> 16) & 255;
    const g2 = (c2 >> 8) & 255;
    const b2 = c2 & 255;
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
  };
  
  /**
   * Get particle color based on streak count
   */
  export const getParticleColorFromStreak = (streak: number): string => {
    if (streak >= 45) return '#FF00FF';
    if (streak >= 35) return '#FF0088';
    if (streak >= 25) return '#FF0000';
    if (streak >= 15) return '#FFA500';
    if (streak >= 5) return '#FFFF00';
    return '#FFD700';
  };
  
  /**
   * Get multiplier value based on streak count
   */
  export const getMultiplierFromStreak = (streak: number): number => {
    return Math.min(10, 1 + Math.floor(streak / 5));
  };
  
  /**
   * Get health bar color based on current health percentage
   */
  export const getHealthBarColor = (health: number): string => {
    const ratio = Math.max(0, Math.min(health / 100, 1));
    const r = Math.round(255 * (1 - ratio));
    const g = Math.round(255 * ratio);
    return `rgb(${r}, ${g}, 0)`;
  };
  
  /**
   * Format time in minutes:seconds format
   */
  export const formatTime = (time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
  };

================
File: src/utils/eventData.ts
================
import { TimedTextEvent, TimedColorEvent, Level2TimedEvents, Level3TimedEvents, Level, LevelToggles } from '../types';

// Default timed text events for level 1
export const createDefaultTimedTextEvents = (): TimedTextEvent[] => [
  { timestamp: 9.35, text: "WELCOME TO CVCHE", triggered: false },
  { timestamp: 11, text: "Save the Reef. Collect The Plastic.", triggered: false },
  { timestamp: 26, text: "Don't Get Sticky!", triggered: false },
  { timestamp: 102, text: "COME ON FLUFFY!", triggered: false },
  { timestamp: 105, text: "PUFF. PUFF. GET FLUFFY!", triggered: false },
  { timestamp: 200, text: "Dance Dance Evolution!", triggered: false },
  { timestamp: 234, text: "Don't Get Hooked!", triggered: false },
  { timestamp: 258, text: "Getting Fluffy!", triggered: false },
  { timestamp: 282, text: "GET FLUFFY - STAY FLUFFY", triggered: false },
  { timestamp: 325, text: "GO BABY GO!", triggered: false },
  { timestamp: 355, text: "ALMOST THERE!", triggered: false },
  { timestamp: 387, text: "YOU ARE AMAZING!", triggered: false },
  { timestamp: 405, text: "FLUFFY LOVES YOU", triggered: false },
  { timestamp: 420, text: "AMAZING JOB FLUFFY! STAY TUNED FOR MORE ADVENTURES! ", triggered: false },
  { timestamp: 431, text: "THE END", triggered: false },
];

// Level 2 timed text events
export const createLevel2TimedTextEvents = (): TimedTextEvent[] => [
  { timestamp: 6, text: "It's 1981. Endless Love by Diana Ross and Lionel Richie is song of the year.", triggered: false, color: "#FDF200", lifetime: 400 },
  { timestamp: 10, text: "But still the world feels unstable.", triggered: false, color: "#FDF200", lifetime: 400 },
  { timestamp: 14, text: "Tina's son Danny was killed in a tragic bus accident.", triggered: false, color: "#FDF200", lifetime: 400 },
  { timestamp: 18, text: "But is Danny really DEAD?", triggered: false, color: "#FDF200" },
  { timestamp: 22, text: "HELP TINA SAVE DANNY!", triggered: false, color: "#FDF200" },
  { timestamp: 26, text: "COME ON FLUFFY!", triggered: false, color: "#FDF200" },
  { timestamp: 36, text: "MMM Vitamin C!", triggered: false, color: "#FDF200" },
  { timestamp: 49, text: "Flying Buses WTF!?", triggered: false, color: "#FDF200" },
  { timestamp: 83, text: "Cock block!", triggered: false, color: "#FDF200" },
  { timestamp: 93, text: "COME ON FLUFFY!", triggered: false, color: "#FDF200" },
  { timestamp: 130, text: "Biological Weapons! You gotta be kidding me.", triggered: false, color: "#FDF200" },
  { timestamp: 135, text: "COME ON FLUFFY!", triggered: false, color: "#FDF200" },
  { timestamp: 173, text: "OH DANNY BOY!", triggered: false, color: "#FDF200" },
  { timestamp: 190, text: "PUFF. PUFF. GET FLUFFY!", triggered: false, color: "#FDF200" },
  { timestamp: 252, text: "HOLY SCHNIKEYS!", triggered: false, color: "#FDF200" },
  { timestamp: 286, text: "DANNY HERE WE COME!", triggered: false, color: "#FDF200" },
  { timestamp: 301, text: "DAAAAAAAAAAAAANNNNNNNNNNYYYYYYYY!!!", triggered: false, color: "#FDF200" },
  { timestamp: 328, text: "GREAT WORK FLUFFY!!! YOU SAVED DANNY!", triggered: false, color: "#FDF200" },
];

// Color change events for level 1
export const createLevel1ColorEvents = (): TimedColorEvent[] => [
  { timestamp: 0, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: true, transitionDuration: 3 },
  { timestamp: 105, backgroundColor: "#FECB07", waveColor: "rgba(254,203,7,0.4)", triggered: false, transitionDuration: 3 },
  { timestamp: 139, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 3 },
  { timestamp: 234, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 240, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 2 },
  { timestamp: 258, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 264, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 274, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 280, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 282, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 288, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 325, backgroundColor: "#F47920", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 330, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 335, backgroundColor: "#FECB07", waveColor: "rgba(254,203,7,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 340, backgroundColor: "#F47920", waveColor: "rgba(244,121,32,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 345, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 350, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 355, backgroundColor: "#A4CE38", waveColor: "rgba(164,206,56,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 360, backgroundColor: "#1489CF", waveColor: "rgba(20,137,207,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 361, backgroundColor: "#ED1D24", waveColor: "rgba(237,29,36,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 362, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 363, backgroundColor: "#FECB07", waveColor: "rgba(254,203,7,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 364, backgroundColor: "#F47920", waveColor: "rgba(244,121,32,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 365, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 390, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 409, backgroundColor: "#A4CE38", waveColor: "rgba(164,206,56,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 410, backgroundColor: "#1489CF", waveColor: "rgba(20,137,207,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 411, backgroundColor: "#ED1D24", waveColor: "rgba(237,29,36,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 412, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 413, backgroundColor: "#FECB07", waveColor: "rgba(254,203,7,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 424, backgroundColor: "#F47920", waveColor: "rgba(244,121,32,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 425, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 426, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 431, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
];

// Color change events for level 2
export const createLevel2ColorEvents = (): TimedColorEvent[] => [
  { timestamp: 0, backgroundColor: "#000000", waveColor: "rgba(0,0,0,0.4)", triggered: true, transitionDuration: 3 },
  /*   { timestamp: 5, backgroundColor: "#1A0A1F", waveColor: "rgba(26,10,31,0.4)", triggered: false, transitionDuration: 3 },
    { timestamp: 49, backgroundColor: "#14142E", waveColor: "rgba(20,20,46,0.4)", triggered: false, transitionDuration: 2 },
    { timestamp: 83, backgroundColor: "#2E0D0D", waveColor: "rgba(46,13,13,0.4)", triggered: false, transitionDuration: 2 },
    { timestamp: 130, backgroundColor: "#1A0A1F", waveColor: "rgba(26,10,31,0.4)", triggered: false, transitionDuration: 3 },
    { timestamp: 173, backgroundColor: "#2E142E", waveColor: "rgba(46,20,46,0.4)", triggered: false, transitionDuration: 2 },
    { timestamp: 190, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 3 },
    { timestamp: 252, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
    { timestamp: 286, backgroundColor: "#2E142E", waveColor: "rgba(46,20,46,0.4)", triggered: false, transitionDuration: 2 },
    { timestamp: 301, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 1 },
    { timestamp: 328, backgroundColor: "#1A0A1F", waveColor: "rgba(26,10,31,0.4)", triggered: false, transitionDuration: 3 }, */
];

// Level 3 timed text events
export const createLevel3TimedTextEvents = (): TimedTextEvent[] => [
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 6, text: "HAVE YOU EVER HAD A FEELING YOU COULD FLY", triggered: false, color: "#020DFF" },
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 30, text: "GET FLUFFY WITH FLUFFY", triggered: false, color: "#020DFF" },
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 71, text: "MMM MUSHROOMS!", triggered: false, color: "#020DFF" },
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 90, text: "FLUFFY THE FLYING FISH", triggered: false, color: "#020DFF" },
  // Blue background (#A0D8EF) -> Complementary color: Orange/Brown (#5F2710)
  { timestamp: 125, text: "MMM MUSHROOMS!", triggered: false, color: "#5F2710" },
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 150, text: "FLY FLUFFY FLY!", triggered: false, color: "#020DFF" },
  // Gray background (#888888) -> Complementary color: Dark Purple (#777777)
  { timestamp: 165, text: "A STORMS A BREWING!", triggered: false, color: "#000000" },
  // Gray background (#888888) -> Complementary color: Dark Purple (#777777)
  { timestamp: 185, text: "WATCH OUT FOR LIGHTING FLUFF!", triggered: false, color: "#000000" },
  // Gray background (#888888) -> Complementary color: Dark Purple (#777777)
  { timestamp: 210, text: "BIRDS OF PREY! WTF!", triggered: false, color: "#000000" },
  // Gray background (#888888) -> Complementary color: Dark Purple (#777777)
  { timestamp: 230, text: "BALD EAGLES TOO!", triggered: false, color: "#000000" },
  // Yellow background (#FDF200) -> Complementary color: Purple/Blue (#020DFF)
  { timestamp: 270, text: "MUSHROOOOOOOOOOOMS!!!", triggered: false, color: "#020DFF" },
  // Magenta background (#FF00FF) -> Complementary color: Green (#00FF00)
  { timestamp: 304, text: "WOWOWOWOWEEEEWOW! THE COLORS!", triggered: false, color: "#00FF00" },
  // Cyan background (#00FFFF) -> Complementary color: Red (#FF0000)
  { timestamp: 340, text: "FLUFFY FLUFF FLUFF! IT'S BEAUTIFUL", triggered: false, color: "#FF0000" },
  // Orange background (#FF8800) -> Complementary color: Blue (#0077FF)
  { timestamp: 370, text: "IT'S SOOO BEAUTIFUL", triggered: false, color: "#0077FF" },
  // Light Purple background (#E6C3E6) -> Complementary color: Green (#193C19)
  { timestamp: 410, text: "HOLY SMOKES! NICE WORK FLUFF!", triggered: false, color: "#193C19" },
];

// Color change events for level 3
export const createLevel3ColorEvents = (): TimedColorEvent[] => [
  //orangehex

  { timestamp: 0.01, backgroundColor: "#fd6100", waveColor: "rgba(253,242,0,0.4)", triggered: true, transitionDuration: 3 },
  { timestamp: 125, backgroundColor: "#A0D8EF", waveColor: "rgba(160,216,239,0.4)", triggered: false, transitionDuration: 2 },
  { timestamp: 150, backgroundColor: "#FF8800", waveColor: "rgba(255,136,0,0.4)", triggered: false, transitionDuration: 2 },
  // Light purple pastels
  { timestamp: 160, backgroundColor: "#E6C3E6", waveColor: "rgba(230,195,230,0.4)", triggered: false, transitionDuration: 2 },
  // Storm colors
  { timestamp: 165, backgroundColor: "#888888", waveColor: "rgba(136,136,136,0.4)", triggered: false, transitionDuration: 2 },
  { timestamp: 270, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  // Trippy color transitions - rapidly changing colors for the psychedelic section
  { timestamp: 304, backgroundColor: "#FF00FF", waveColor: "rgba(255,0,255,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 315, backgroundColor: "#00FFFF", waveColor: "rgba(0,255,255,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 325, backgroundColor: "#FF8800", waveColor: "rgba(255,136,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 335, backgroundColor: "#A8238E", waveColor: "rgba(168,35,142,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 345, backgroundColor: "#14AEEF", waveColor: "rgba(20,174,239,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 355, backgroundColor: "#A4CE38", waveColor: "rgba(164,206,56,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 365, backgroundColor: "#E6C3E6", waveColor: "rgba(230,195,230,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 375, backgroundColor: "#FF00FF", waveColor: "rgba(255,0,255,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 385, backgroundColor: "#00FFFF", waveColor: "rgba(0,255,255,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 395, backgroundColor: "#FF8800", waveColor: "rgba(255,136,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 405, backgroundColor: "#FDF200", waveColor: "rgba(253,242,0,0.4)", triggered: false, transitionDuration: 1 },
  { timestamp: 410, backgroundColor: "#E6C3E6", waveColor: "rgba(230,195,230,0.4)", triggered: false, transitionDuration: 1 },
];

// Function to return color events based on level ID
export const createColorEventsByLevel = (levelId: number): TimedColorEvent[] => {
  switch (levelId) {
    case 1:
      return createLevel1ColorEvents();
    case 2:
      return createLevel2ColorEvents();
    case 3:
      return createLevel3ColorEvents();
    default:
      return createLevel1ColorEvents();
  }
};

// Level 3 timed events for obstacles, pickups, and visuals
export const createLevel3TimedEvents = (): Level3TimedEvents => ({
  obstacles: [
    // Eagles as obstacles
    { timestamp: 210, type: 'eagle', triggered: false },
    { timestamp: 215, type: 'eagle', triggered: false },
    { timestamp: 220, type: 'eagle', triggered: false },
    // More eagles at 230s
    { timestamp: 230, type: 'eagle', triggered: false },
    { timestamp: 235, type: 'eagle', triggered: false },
    { timestamp: 240, type: 'eagle', triggered: false },
    { timestamp: 245, type: 'eagle', triggered: false },
    { timestamp: 250, type: 'eagle', triggered: false },
    { timestamp: 255, type: 'eagle', triggered: false },
    { timestamp: 260, type: 'eagle', triggered: false },
    // Clouds rising at beginning
    { timestamp: 3, type: 'cloud', triggered: false },
    // Floating clouds
    { timestamp: 30, type: 'cloud', triggered: false },
    { timestamp: 40, type: 'cloud', triggered: false },
    { timestamp: 50, type: 'cloud', triggered: false },
    { timestamp: 60, type: 'cloud', triggered: false },
    // Storm clouds
    { timestamp: 165, type: 'cloud', variant: 'storm', triggered: false },
    { timestamp: 170, type: 'cloud', variant: 'storm', triggered: false },
    { timestamp: 175, type: 'cloud', variant: 'storm', triggered: false },
    { timestamp: 180, type: 'cloud', variant: 'storm', triggered: false },
  ],
  pickups: [
    // Mushrooms as pickups
    { timestamp: 71, type: 'mushroom', variant: '1', triggered: false },
    { timestamp: 75, type: 'mushroom', variant: '2', triggered: false },
    { timestamp: 80, type: 'mushroom', variant: '3', triggered: false },
    { timestamp: 85, type: 'mushroom', variant: '4', triggered: false },
    { timestamp: 125, type: 'mushroom', variant: '5', triggered: false },
    { timestamp: 130, type: 'mushroom', variant: '6', triggered: false },
    { timestamp: 135, type: 'mushroom', variant: '7', triggered: false },
    { timestamp: 140, type: 'mushroom', variant: '8', triggered: false },
    { timestamp: 270, type: 'mushroom', variant: '9', triggered: false },
    { timestamp: 275, type: 'mushroom', variant: '1', triggered: false },
    { timestamp: 280, type: 'mushroom', variant: '2', triggered: false },
    { timestamp: 285, type: 'mushroom', variant: '3', triggered: false },
    { timestamp: 290, type: 'mushroom', variant: '4', triggered: false },
    { timestamp: 295, type: 'mushroom', variant: '5', triggered: false },
    { timestamp: 300, type: 'mushroom', variant: '6', triggered: false },
    // Trippy visuals starting at 304s
    { timestamp: 304, type: 'trippy', variant: 'gummyWorm', triggered: false },
    { timestamp: 310, type: 'trippy', variant: 'magicRabbit', triggered: false },
    { timestamp: 316, type: 'trippy', variant: 'baby', triggered: false },
    { timestamp: 322, type: 'trippy', variant: 'kitten', triggered: false },
    { timestamp: 328, type: 'trippy', variant: 'pomeranian', triggered: false },
    { timestamp: 334, type: 'trippy', variant: 'squirtToy', triggered: false },
    { timestamp: 340, type: 'trippy', variant: 'baby2', triggered: false },
    { timestamp: 346, type: 'trippy', variant: 'blueMan', triggered: false },
    { timestamp: 352, type: 'trippy', variant: 'woman', triggered: false },
    { timestamp: 358, type: 'trippy', variant: 'gummyWorm', triggered: false },
    { timestamp: 364, type: 'trippy', variant: 'magicRabbit', triggered: false },
    { timestamp: 370, type: 'trippy', variant: 'baby', triggered: false },
    { timestamp: 376, type: 'trippy', variant: 'kitten', triggered: false },
    { timestamp: 382, type: 'trippy', variant: 'pomeranian', triggered: false },
    { timestamp: 388, type: 'trippy', variant: 'squirtToy', triggered: false },
    { timestamp: 394, type: 'trippy', variant: 'baby2', triggered: false },
    { timestamp: 400, type: 'trippy', variant: 'blueMan', triggered: false },
  ]
});

// Level 2 timed events for obstacles and pickups
export const createLevel2TimedEvents = (): Level2TimedEvents => ({
  obstacles: [
    // Flying Buses - starting around 49 second mark
    { timestamp: 49, type: 'bus', triggered: false },
    { timestamp: 55, type: 'bus', triggered: false },
    { timestamp: 62, type: 'bus', triggered: false },

    // Chickens - starting around 83 second mark
    { timestamp: 83, type: 'chicken', triggered: false },
    { timestamp: 88, type: 'chicken', triggered: false },
    { timestamp: 93, type: 'chicken', triggered: false },

    // Bats - starting around 120 second mark
    { timestamp: 120, type: 'bats', triggered: false },
    { timestamp: 125, type: 'bats', triggered: false },
    { timestamp: 130, type: 'bats', triggered: false },

    // Mixed obstacles - around 173 mark (all obstacles randomly mixed)
    { timestamp: 173, type: 'bus', triggered: false },
    { timestamp: 176, type: 'chicken', triggered: false },
    { timestamp: 180, type: 'bats', triggered: false },
    { timestamp: 185, type: 'bus', triggered: false },
    { timestamp: 188, type: 'chicken', triggered: false },
    { timestamp: 192, type: 'bats', triggered: false },

    // Major shift at 252 - HOLY SCHNIKEYS! moment
    { timestamp: 252, type: 'bus', triggered: false },
    { timestamp: 255, type: 'chicken', triggered: false },
    { timestamp: 258, type: 'bats', triggered: false },
    { timestamp: 262, type: 'bus', triggered: false },
    { timestamp: 266, type: 'chicken', triggered: false },
    { timestamp: 270, type: 'bats', triggered: false },

    // Final extreme obstacle flood for the outro at 301 mark
    { timestamp: 301, type: 'bats', triggered: false },
    { timestamp: 302, type: 'bats', triggered: false },
    { timestamp: 303, type: 'bats', triggered: false },
    { timestamp: 304, type: 'bats', triggered: false },
    { timestamp: 305, type: 'bats', triggered: false },
    { timestamp: 306, type: 'bats', triggered: false },
    { timestamp: 307, type: 'bats', triggered: false },
    { timestamp: 308, type: 'bats', triggered: false },
    { timestamp: 310, type: 'bats', triggered: false },
    { timestamp: 312, type: 'bats', triggered: false }
  ],
  pickups: [
    // Orange Slices (VitaminC) incoming at 28 seconds
    { timestamp: 28, type: 'vitaminC', triggered: false },
    { timestamp: 32, type: 'vitaminC', triggered: false },
    { timestamp: 36, type: 'vitaminC', triggered: false },

    // Ginger comes at 36 second mark
    { timestamp: 36, type: 'ginger', triggered: false },
    { timestamp: 40, type: 'ginger', triggered: false },
    { timestamp: 44, type: 'ginger', triggered: false },

    // Mix of health items during mid-game
    { timestamp: 70, type: 'pill', triggered: false },
    { timestamp: 80, type: 'tumeric', triggered: false },
    { timestamp: 90, type: 'vitaminC', triggered: false },
    { timestamp: 100, type: 'ginger', triggered: false },
    { timestamp: 110, type: 'pill', triggered: false },

    // More pickups during intense sections
    { timestamp: 150, type: 'tumeric', triggered: false },
    { timestamp: 160, type: 'vitaminC', triggered: false },
    { timestamp: 170, type: 'ginger', triggered: false },

    // Continued pickups during mixed obstacle section
    { timestamp: 200, type: 'pill', triggered: false },
    { timestamp: 220, type: 'tumeric', triggered: false },
    { timestamp: 240, type: 'vitaminC', triggered: false },

    // Final stretch pickups
    { timestamp: 280, type: 'ginger', triggered: false },
    { timestamp: 290, type: 'pill', triggered: false }
  ]
});

// Default game levels
export const getDefaultLevels = (): Level[] => {
  return [
    {
      id: 1,
      title: "WELCOME TO CVCHE",
      songFile: "https://storage.googleapis.com/assets.urnowhere.com/publicmedia/cvche/welcomeToCVCHE.mp3",
      initialBackground: "#FDF200",
      initialWaveColor: "rgba(253,242,0,0.4)",
      unlocked: true,
      isCaveMechanic: false,
      highScore: 0,
      highestStreak: 0
    },
    {
      id: 2,
      title: "Eyes of Darkness",
      songFile: "https://storage.googleapis.com/assets.urnowhere.com/publicmedia/cvche/Eyes_of_Darkness.mp3",
      initialBackground: "#000000",
      initialWaveColor: "rgba(0,0,0,0.4)",
      unlocked: true,
      isCaveMechanic: false,
      highScore: 0,
      highestStreak: 0
    },
    {
      id: 3,
      title: "Fluffy the Flying Fish",
      songFile: "sounds/GetFluffy.mp3",
      initialBackground: "#FDF200",
      initialWaveColor: "rgba(253,242,0,0.4)",
      unlocked: true,
      isCaveMechanic: false, // For the storm section with cave mechanics
      highScore: 0,
      highestStreak: 0
    }
  ];
};

// Initial level toggles state
export const getInitialLevelToggles = (): LevelToggles => ({
  showFlora: false,
  showBags: false,
  showBottles: false,
  showOilSplats: false,
  showHooks: false,
  showVisualizer: false,
  showBubbles: false,
  showBackgroundPattern: false,
  showFlipFlops: false,
  showToothbrushes: false,
  showHotdogs: false,
  showRubberDuckies: false,
  // Level 2 specific obstacle toggles
  showBuses: false,
  showBats: false,
  showChickens: false,
  // Level 3 specific toggles
  showClouds: false,
  showMushrooms: false,
  showEagles: false,
  showTrippyObjects: false,
  showStormEffects: false
});

================
File: src/App.css
================
#root {
  margin: 0 auto;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
// src/App.tsx
import React, { useState, useEffect } from 'react';
import './App.css';
import MusicReactiveOceanGame from './components/MusicReactiveOceanGame';

const App: React.FC = () => {
  const [isPlaying, setIsPlaying] = useState(false);

  // Prevent pull-to-refresh and other touch gestures
  useEffect(() => {
    console.log('App mounted, isPlaying:', isPlaying);
    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    return () => {
      document.body.removeEventListener('touchmove', (e) => {
        e.preventDefault();
      });
    };
  }, []);

  return (
    <div style={{
      width: '100vw',
      height: '100vh',
      position: 'relative',
      overflow: 'hidden',
      fontFamily: 'Orbitron, sans-serif'
    }}>
      <MusicReactiveOceanGame onGameStart={() => setIsPlaying(true)} />
    </div>
  );
};

export default App;

================
File: src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  height: 100%;
  width: 100%;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
  overflow: hidden;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/index.ts
================
// Main Game Component
export { default as MusicReactiveOceanGame } from './components/MusicReactiveOceanGame';

// Types
export * from './types';

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: src/types.ts
================
export interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  color: string;
  size: number;
  opacity: number;
  shape?: 'circle' | 'heart';
}
//Level2TimedEvents
export interface Level2TimedEvents {
  obstacles: Level2TimedEvent[];
  pickups: Level2TimedEvent[];
}
//Level2TimedEvent
export interface Level2TimedEvent {
  timestamp: number;
  type: 'bus' | 'bats' | 'chicken' | 'vitaminC' | 'pill' | 'tumeric' | 'ginger';
  triggered: boolean;
}

//Level3TimedEvents
export interface Level3TimedEvents {
  obstacles: Level3TimedEvent[];
  pickups: Level3TimedEvent[];
}
//Level3TimedEvent
export interface Level3TimedEvent {
  timestamp: number;
  type: 'mushroom' | 'cloud' | 'eagle' | 'trippy';
  variant?: string; // For different trippy objects or mushroom types
  triggered: boolean;
}
//Level
export interface Level {
  id: number;
  title: string;
  songFile: string;
  initialBackground: string;
  initialWaveColor: string;
  unlocked: boolean;
  isCaveMechanic?: boolean;
  highScore?: number;
  highestStreak?: number;
}

//CaveState
export interface CaveState {
  upper: { points: CavePoint[], amplitude: number },
  lower: { points: CavePoint[], amplitude: number }
}

//points 
export interface CavePoint {
  x: number;
  y: number;
} 


//Player
export interface Player {
  x: number;
  y: number;
  width: number;
  height: number;
  vy: number;
  speed: number;
  rotation: number;
  spinRotation: number;
  hitTime?: number;
  hitType?: 'trash' | 'obstacle' | 'fishhook' | 'flipflop' | 'toothbrush' | 'hotdog' | 'rubberducky';
}

//GameState
export interface GameState {
  level: Level;
  levelToggles: LevelToggles;
  score: number;
  streak: number;

  highScore: number;
  highestStreak: number;
  time: number;
  paused: boolean;
  gameOver: boolean;
  gameStarted: boolean;
  gameEnded: boolean;
  gameItems: GameItem[];
  particles: Particle[];
  pickups: GameItem[];
  trashStats: TrashStats;
  obstacles: GameItem[];
  scorePopups: ScorePopup[];
  timedTextEvents: TimedTextEvent[];
  activeTimedText: ActiveTimedText;
  timedColorEvents: TimedColorEvent[];
  activeColor: ActiveColor;
  bubbles: Bubble[];
  flora: Flora[];
  streakDisplay: StreakDisplay;
  multiplier: number;
  player: Player;
}

//TrashStats { totalSpawned: 0, collected: 0, missed: 0 }
export interface TrashStats {
  totalSpawned: number;
  collected: number;
  missed: number;
}

export interface GameItem {
  x: number;
  y: number;
  width: number;
  height: number;
  type: 'trash' | 'obstacle' | 'fishhook' | 'flipflop' | 'toothbrush' | 'hotdog' | 'rubberducky';
  speed: number;
  rotation?: number;
  pickupImage?: HTMLImageElement;
  baseY?: number;
  // For trippy warping effects in level 3
  warpFactor?: number;
  warpSpeed?: number;
  warpOffset?: number;
}

export interface ExtendedHTMLAudioElement extends HTMLAudioElement {
  _mediaElementSource?: MediaElementAudioSourceNode;
  _audioCtx?: AudioContext;
}

export interface ScorePopup {
  x: number;
  y: number;
  text: string;
  opacity: number;
  lifetime: number;
}

export interface TimedTextEvent {
  timestamp: number;
  text: string;
  triggered: boolean;
  color?: string; // Optional text color property
  lifetime?: number;
}

export interface ActiveTimedText {
  text: string;
  lifetime: number;
  color: string;
}

export interface TimedColorEvent {
  timestamp: number;
  backgroundColor: string;
  waveColor: string;
  triggered: boolean;
  transitionDuration: number; // in seconds
}

export interface ActiveColor {
  backgroundColor: string;
  waveColor: string;
  progress: number;
  targetBackgroundColor: string;
  targetWaveColor: string;
  transitionDuration: number;
}

export interface Bubble {
  x: number;
  y: number;
  radius: number;
  speed: number;
  opacity: number;
}

export interface Flora {
  x: number;
  y: number;
  width: number;
  height: number;
  image: HTMLImageElement;
  swayOffset: number;
  swaySpeed: number;
  scrollSpeed: number;
  active: boolean; // Add this property
}

export interface StreakDisplay {
  x: number;
  y: number;
  scale: number;
  opacity: number;
}

export interface Level {
  id: number;
  title: string;
  songFile: string;
  initialBackground: string;
  initialWaveColor: string;
  unlocked: boolean;
  isCaveMechanic?: boolean;
  highScore?: number; // Add this property
  highestStreak?: number; // NEW: Save highest streak here
}

export interface LevelToggles {
  showFlora: boolean;
  showBags: boolean;         // replaced showTrash
  showBottles: boolean;       // replaced showTrash
  showOilSplats: boolean;
  showHooks: boolean;
  showVisualizer: boolean;
  showBubbles: boolean;
  showBackgroundPattern: boolean;
  showFlipFlops: boolean;
  showToothbrushes: boolean;
  showHotdogs: boolean;
  showRubberDuckies: boolean;
  // Level 2 specific obstacle toggles
  showBuses?: boolean;
  showBats?: boolean;
  showChickens?: boolean;
  // Level 3 specific toggles
  showClouds?: boolean;
  showMushrooms?: boolean;
  showEagles?: boolean;
  showTrippyObjects?: boolean;
  showStormEffects?: boolean;
}

export interface Props {
  onGameStart?: () => void;
}

export interface GameProps {
  onGameStart?: () => void;
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RFNRTJ4C38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-RFNRTJ4C38');
  </script>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/sprites/cvcheFish.webp" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CVCHE</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================
File: netlify.toml
================
[build]
  command = "npm run build"
  publish = "dist"
  base = "/"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

================
File: package.json
================
{
  "name": "cvche",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "phaser": "^3.87.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.19.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.18",
    "globals": "^15.14.0",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.22.0",
    "vite": "^6.1.0"
  }
}

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
